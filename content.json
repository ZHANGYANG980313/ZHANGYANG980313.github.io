{"meta":{"title":"YumeSama","subtitle":null,"description":"个人博客","author":"Yume","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-05-04T12:36:36.173Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-10-18T11:56:44.169Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Yume] 与&nbsp; Yume&nbsp; （ 梦（ゆめ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Yume\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于南京邮电大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术与美术的结合\" }).then(function () { botui.message.add({ delay: 1200, content: \"但却没有美术基础ToT\" }).then(function () { botui.message.add({ delay: 1500, content: \"时常懊恼自己为什么不是个美术生\" }).then(function () { botui.message.add({ delay: 1500, content: \"目前研究的方向是图形学(Computer Graphics)中的渲染及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢做游戏，接触游戏制作一年多了\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Yume呢？ 🤔\", value: \"why-Yume\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Yume是罗马音，日文的意思为梦\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"博客会记录些什么呢？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmmm大概是一些技术文章和随想吧。。。借此机会提高语言水平= =。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-05-03T14:27:17.420Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-05-03T14:27:17.422Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-05-03T14:27:17.423Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-18T11:26:17.290Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-05-03T14:27:17.425Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-05-03T14:27:17.429Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-05-03T14:27:17.431Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-05-03T14:27:17.434Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-10-18T12:01:44.632Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-03T14:27:17.437Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"ChararterRendering-VIII","slug":"ChararterRendering-VIII","date":"2019-10-17T11:45:05.000Z","updated":"2019-10-17T12:00:32.830Z","comments":true,"path":"2019/10/17/ChararterRendering-VIII/","link":"","permalink":"/2019/10/17/ChararterRendering-VIII/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-VII","slug":"ChararterRendering-VII","date":"2019-10-17T11:44:58.000Z","updated":"2019-10-17T11:47:02.555Z","comments":true,"path":"2019/10/17/ChararterRendering-VII/","link":"","permalink":"/2019/10/17/ChararterRendering-VII/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-VI","slug":"ChararterRendering-VI","date":"2019-10-17T11:37:06.000Z","updated":"2019-10-17T11:41:41.912Z","comments":true,"path":"2019/10/17/ChararterRendering-VI/","link":"","permalink":"/2019/10/17/ChararterRendering-VI/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-V","slug":"ChararterRendering-V","date":"2019-10-17T11:36:55.000Z","updated":"2019-10-17T11:40:05.394Z","comments":true,"path":"2019/10/17/ChararterRendering-V/","link":"","permalink":"/2019/10/17/ChararterRendering-V/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-IV","slug":"ChararterRendering-IV","date":"2019-10-17T11:19:52.000Z","updated":"2019-10-17T11:36:02.432Z","comments":true,"path":"2019/10/17/ChararterRendering-IV/","link":"","permalink":"/2019/10/17/ChararterRendering-IV/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-III","slug":"ChararterRendering-III","date":"2019-10-17T11:16:58.000Z","updated":"2019-10-17T11:18:57.592Z","comments":true,"path":"2019/10/17/ChararterRendering-III/","link":"","permalink":"/2019/10/17/ChararterRendering-III/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-II","slug":"ChararterRendering-II","date":"2019-10-17T11:12:02.000Z","updated":"2019-10-17T11:16:30.873Z","comments":true,"path":"2019/10/17/ChararterRendering-II/","link":"","permalink":"/2019/10/17/ChararterRendering-II/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"ChararterRendering-I","slug":"ChararterRendering-I","date":"2019-10-17T11:04:01.000Z","updated":"2019-10-17T11:11:17.272Z","comments":true,"path":"2019/10/17/ChararterRendering-I/","link":"","permalink":"/2019/10/17/ChararterRendering-I/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Yume-《Yume》","slug":"Yume-《Yume》","date":"2019-10-17T10:37:12.000Z","updated":"2019-10-17T10:52:47.225Z","comments":true,"path":"2019/10/17/Yume-《Yume》/","link":"","permalink":"/2019/10/17/Yume-《Yume》/","excerpt":"","text":"这是我们团队3天极限开发做的作品，在这里只放一些Fadom同学涂过的概念图。美术风格参考了《RIME》。感谢Fadom同学提供的原画。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"FinalFantasy（致谢场景）","slug":"FinalFantasy（致谢场景）","date":"2019-10-17T10:03:42.000Z","updated":"2019-10-17T10:28:17.294Z","comments":true,"path":"2019/10/17/FinalFantasy（致谢场景）/","link":"","permalink":"/2019/10/17/FinalFantasy（致谢场景）/","excerpt":"","text":"钢琴&amp;树最近看到了Deemo重制版的PV，挺有感触的。。结合Deemo的设定中演奏钢琴可以使树木生长，设计了这么一个场景。 绘马起初是看到了在丽江时候拍摄的许愿架，有了这样一个想法，众筹的致谢名单如果只是视频播放一遍未免太过无趣，所以制作了这样一个场景。感谢Bot同学的程序化，使得场景中出现了1200余个独一无二的祈愿牌。（截图的时候意外发现一位朋友的朋友出现在了镜头中0.0） 枫叶枫叶是坚毅的象征，也略带些思念的味道，希望这个场景能够成为一个回忆之地，寄托了我们所有人美好的愿望。如果是购买了游戏的朋友，可以听见这个场景中的两段音乐，分别是秋山裕和的《Moment》与《砂之雫》。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Fantasy-Scene-03（幻想场景3-月之泪？）","slug":"Fantasy-Scene-03（幻想场景3-月之泪？）","date":"2019-10-17T09:43:36.000Z","updated":"2019-10-17T10:00:19.430Z","comments":true,"path":"2019/10/17/Fantasy-Scene-03（幻想场景3-月之泪？）/","link":"","permalink":"/2019/10/17/Fantasy-Scene-03（幻想场景3-月之泪？）/","excerpt":"","text":"一直都想还原下《尼尔：机械纪元》的月之泪场景，尼尔真是太棒了，各种意义上。以下有些是实机和Fadom涂过的对比。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Fantasy-Scene-02（幻想场景2-月下的海滩）","slug":"Fantasy-Scene-02（幻想场景2-月下的海滩）","date":"2019-10-17T08:07:47.000Z","updated":"2019-10-17T09:44:23.331Z","comments":true,"path":"2019/10/17/Fantasy-Scene-02（幻想场景2-月下的海滩）/","link":"","permalink":"/2019/10/17/Fantasy-Scene-02（幻想场景2-月下的海滩）/","excerpt":"","text":"主要元素灯塔、帆船、海面与灯笼。其实一开始是非常想模仿海兽之子PV的那个场景的Orz。奈何能力有限，不了了之了。 战队视频在参加MG比赛的时候，用这个场景做了一个战队视频，想模仿下鬼泣开场的镜头，太炫了。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Fantasy-Scene-01（幻想场景1-湖中央的樱花树）","slug":"Fantasy-Scene-01（幻想场景1-湖中央的樱花树）","date":"2019-06-20T18:32:33.000Z","updated":"2019-10-17T09:31:52.803Z","comments":true,"path":"2019/06/21/Fantasy-Scene-01（幻想场景1-湖中央的樱花树）/","link":"","permalink":"/2019/06/21/Fantasy-Scene-01（幻想场景1-湖中央的樱花树）/","excerpt":"","text":"樱花树这是一颗400mb的樱花树，没错。。。其实还没做优化前做到了1.7g，咳。。怕被队友打死还是优化了下，用的SpeedTree软件，真的非常方便，效果也很好。 湖面其实是很早在gumroad购买的一个水面包，自带水面分隔的效果，水下体积雾，水面的次表面，稍微调了调非常的梦幻。 隧道隧道其实是一个独立的关卡，但是内容太少就放在这个里面一起讲了，在隧道关卡里的VXGI是开启的，主要是火车中金属物件较多，反射会很好看，另外隧道外的路灯也可以造成一点光影的变化，这在之前用灯光是很难实现的。隧道是通过instance生成了几百个连接在一起的隧道。 渲染依然是全动态，且并没有开启VXGI，这里主要用到的是平面反射(Planar Reflection)，这是个很消耗的反射，但是这个场景复杂度极低，平面反射的效果十分优秀。 氛围这个场景中我加入了鸟群和飘落的樱花的粒子，并配合剧情需要修改整体的色调为黑白色（后面会回归彩色嘻嘻敬请期待），并加入了Instance环形旋转的蓝图（Youtube嫖的）让火车飘在空中体现出一种崩坏压抑的感觉（Fadom说很尼尔），可能也是受到了尼尔的影响hh，尼尔的环境真是太棒了。后期其他方面依然是选择了SSAO+Lightshaft+VolumeFog+Bloom等等，慢慢调出的效果。 下一篇下一篇当然是Fantasy_Scene_02啦","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"学姐的照骗","slug":"学姐的照骗","date":"2019-06-20T16:39:43.000Z","updated":"2019-06-20T18:28:21.136Z","comments":true,"path":"2019/06/21/学姐的照骗/","link":"","permalink":"/2019/06/21/学姐的照骗/","excerpt":"","text":"也不能完全说是照骗，这种风格是学姐无意中用截图涂出来的，那张图甚至是我随意用qq截的图Orz，当时拿给我看的时候整个人都惊呆了，会画画真的可以为所欲为QAQ，放出一些对比： 给跪了Orz。。。今后的幻想场景也让学姐画一点吧。。太好看了。。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Bedroom（现实场景2）","slug":"Bedroom（现实场景2）","date":"2019-06-20T15:06:46.000Z","updated":"2019-06-20T16:11:29.528Z","comments":true,"path":"2019/06/20/Bedroom（现实场景2）/","link":"","permalink":"/2019/06/20/Bedroom（现实场景2）/","excerpt":"","text":"白天依旧是全动态VXGI的加持，购买的商城免费的日夜循环蓝图，选了一个比较好看的太阳光角度，这是第一个版本。。当时策划给的感觉是杂乱，所以就很佛系摆场景了，甚至自己用bsp建了一个飘窗，莫名还挺好看的hhhh。后面有次大概了场景风格，所以上线版本看到的是一个整齐又诡异的版本。多图预警：偶尔尝试了下kuwahara风格感觉还可以。 夜晚夜晚这里就不得不吹一波vxgi了，效果十分好，需要注意的是一定要把r.VXGI.VoxelSize 调到2左右，开了AO之后场景的亮度会正常许多。这里就拿以前的一些老图来了。。懒得去截取了，可能与实机效果不太一样，因为改动了很多。 复赛可能会增加的改动在考虑到玩家第一次会触发Bad End的剧情，小组里打算在二周目做一些不一样的变化，我的想法是加入一个可供探索的阁楼，月光照射进来的感觉会非常棒~~~ 下一篇下篇将会开始介绍幻想场景也是开始放飞自我的场景了","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Home（现实场景1）","slug":"Home（现实场景1）","date":"2019-06-20T13:21:44.000Z","updated":"2019-06-20T14:40:23.084Z","comments":true,"path":"2019/06/20/Home（现实场景1）/","link":"","permalink":"/2019/06/20/Home（现实场景1）/","excerpt":"","text":"布局这个场景的布局其实。。是参考了《底特律：变人》的，因为我实在是没做过样板间（对，就是有些排斥），甚至借来了学弟的PS4重玩了一遍前几个章节，对主角的家渐渐有了些想法，做成了两层的复式，一楼的客厅当时没考虑好结果弄的太大了。。。所有的建筑都是用UE4的BSP直接建模的，发现BSP做这种家装的实在是太适合了，打洞十分方便。 VXGI 2.0烘焙是不可能的，这辈子不可能用UE4的Lightmass烘焙的= =，刚好之前做学校作业编译了个4.21的VXGI 2.0引擎，尝试了下效果还可以接受就大家人手一份了，简直不要太方便。。VXGI特别适合做这种小场景的光照，GI（全局光照）可能不如烘焙的效果，但是反射几乎可以吊打UE4默认的反射球，VXSpecular和SSR（屏幕空间反射）的融合效果也很不错，AO（环境光遮蔽）方面VXAO远比UE4引擎默认的SSAO看着舒服多了。如果有想玩的朋友可以私信我拿一份，15G还送一部《利兹与青鸟》其实是无聊做了一个看电影的房间忘记删了，我是有多无聊提一下比较重要的几个点： 注意r.VXGI.VoxelSize与r.VXGI.MapSizeX/Y/Z这几个参数 不要使用双面材质，除非万不得已，物体的面数不宜太高，会发光= =，对，会发光 这个bug我找了几个小时，像是VXGI的多次反弹算炸了。 如果特别卡，看下是不是有粗糙度很低的物体，而且法线看起来很复杂，未知BUG，会导致屏幕中出现的物体越大越卡，十分的坑，解决办法嘛= = 把法线删了，增加粗糙度，我也很无奈，VXGI慎用、慎用。 透光（光源直接穿过墙壁）现象十分严重，需注意。 使用vxao就不要用ssao了，不然墙角会十分的黑（有了vxao还要啥ssao 没事多用缓冲器可视化看看Diffuse、Specular、AO是否正确 外景外景其实是完全没有被体素的，和引擎默认的全动态没有区别，要注意的就是天光的cubemap的捕捉或选择以及调色了，疯狂调后期。。DOF、Kuwahara、Bloom、LightShaft、Volume Fog、SSAO、Contact Shadow等等全怼上。。。。。GI?啥GI，UE4有外景的GI解决方案吗？。。。。别动不动就烘焙。。。特别是外景，这是很多新手喜欢犯的毛病，也包括我。烘焙不一定能让场景好看，后期和材质才是最主要的。 下一篇下一篇会介绍女主房间以及我和策划的设计灵感","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"网易GameJam之行（开篇）","slug":"网易GameJam之行（开篇）","date":"2019-06-20T11:46:49.000Z","updated":"2019-06-20T13:15:57.009Z","comments":true,"path":"2019/06/20/网易GameJam之行（开篇）/","link":"","permalink":"/2019/06/20/网易GameJam之行（开篇）/","excerpt":"","text":"首先Po上比赛的链接吧没错那个Freud Gate就是我们(xз」∠)。 组队可以说是脑子一热就参加了这个比赛，团队从原来的3个人，6个人，再到最后的7个人，逐渐庞大了起来。一开始还是慌的不行的，因为我已经好几个月没有碰UE4了，说起做游戏，那更是一年前的事情了，我拒绝了程序一职，因为知道自己的蓝图实在是太菜了，最终我成为了团队中的场景美术，哼，我要成为Environment Artist~~~ 磨合为了更好的参加这个比赛，我计划咕掉了一个的考研复习，现在已经过去一个多月了。回想起来丝毫不曾后悔所做出的决定，果然还是做自己喜欢做的事情快乐(xз」∠)，更快乐的是能和朋友们一起为着共同的目标而努力着。在此之中，大家都发挥了非常重要的作用，有参加过上线项目的主程序；有做过场做shader做程序的Bot；有会编曲、娇喘、剪视频的策划；有做模型的猪猪；有会一手好绑定+K动画的动画师；还有画画很好看的学姐（这里的图都是学姐画的）；当然还有负责除了场景美术外各种打杂事物的我自己（自吹一波，果然之前积累的很多经验派上用场了~~ 中场休息目前是提交了初赛作品等待评审的时间，看到许多人对我们作品的评价还是很高兴的，现在是每天在复习之外想想之后的场景该怎么做，以及没事水水群。宝可梦村真是太跳了(xз」∠) 之后的博客之后的几篇会更新一些我所做的每个场景的一些制作细节及经验分享，从室内小场景到室外偏大的场景，希望对一些刚刚入门的朋友有所帮助。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Photogrammetry流程学习回忆","slug":"Photogrammetry流程学习回忆","date":"2019-05-06T14:22:11.000Z","updated":"2019-05-06T18:03:39.827Z","comments":true,"path":"2019/05/06/Photogrammetry流程学习回忆/","link":"","permalink":"/2019/05/06/Photogrammetry流程学习回忆/","excerpt":"","text":"云南之行首先能接触到这个方向，还是受Bot大佬的影响，在大二暑假的时候于网上结识的一个朋友，随后一起去了云南那边进行了采风活动。。。其实到了发现就我们两个人。那个时候有点一言难尽，我的身体很吃不消高原的环境，而且发现都还是刚刚开始学习，流程也非常的简陋,各种环节都十分不熟悉……在香格里拉的旅馆躺了几天，去了几趟医院，我便一个人先去了丽江。那个时候做的东西，大概是这样的： EMMMMMMM中间那个树是在第一次改进流程后做的，效果还可以，只是当时有点神经手动分了几万面的UV，快吐了，现在什么都是扔给ZB一键自动分或者用其他的自动化工具。 无语的项目暑假刚过完便开始了院里强制参加的Stitp（大学生创新训练计划）项目（莫名其妙成了省重点项目），便用上了暑假刚学的扫描流程。。。有种赶鸭子上架的感觉，所做的许多材质都十分粗糙，做完了都不会去预览下的那种，每天处理完一堆贴图模型就统一全部导入，很少出现返工的素材。效果如下： 还是直接扔视频吧： 庐山之行寒假的时候，和Bot又约了波庐山，此时的流程已经有了很大的进步了，无论是速度还是质量上，从硬件到软件，比第一次在云南做的进步了不止一点半点。 Bot还专门为我们的流程开发了一系列工具，什么在UE4里画贴图，去光等各种神奇的操作（蓝图还能这么玩）。效果图： 加一些采风时的照片~~~ 找到Bot在哪了吗： 咳。。。。这是我 作死下去的水库： 今后的目标当然是先打败Rens，就是Artstation的这个家伙： 还有很长一段路需要走。。。。等考完研结束再和Bot继续约吧，来日方长。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"博客搭建随想","slug":"博客搭建随想","date":"2019-05-04T14:01:59.000Z","updated":"2019-05-04T14:07:21.850Z","comments":true,"path":"2019/05/04/博客搭建随想/","link":"","permalink":"/2019/05/04/博客搭建随想/","excerpt":"","text":"封面画师：Miv4t搭建这个博客，前前后后大概用了4天吧，像是中了毒一样……..在博客美化的路上停不下来，也遇上了很多很多的坑，比如CDN、图床、RSS、CSS语法、域名、备案之类的，昨晚为了转载大佬的文章到自己的博客方便查阅还学习了下爬虫方面的知识。一步步摸索过来了，还是比较简单的。所以有想法想和我一样搭建一个属于自己的博客的童鞋不要害怕，Hexo引擎搭建遇到的坑百度百度很容易就能解决的。 不过还是存在一个很严重的问题，极度依赖别人的主题很容易撞车…….自己的博客和别人的看起来一样还是挺不爽的，以后有时间可能会写一个属于自己的主题吧，如今能力还不够，也没精力再去折腾这个了，好好考研才是正道~~","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"DarlingInTheFranxx图集(流量预警)","slug":"DarlingInTheFranxx图集","date":"2019-05-04T12:40:17.000Z","updated":"2019-05-04T13:07:04.802Z","comments":true,"path":"2019/05/04/DarlingInTheFranxx图集/","link":"","permalink":"/2019/05/04/DarlingInTheFranxx图集/","excerpt":"","text":"1-10 11-20 21-30 31-41","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[{"name":"图集","slug":"图集","permalink":"/tags/图集/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"Hexo搭建笔记","slug":"Hexo搭建笔记","date":"2019-05-03T17:15:59.000Z","updated":"2019-05-03T20:15:01.295Z","comments":true,"path":"2019/05/04/Hexo搭建笔记/","link":"","permalink":"/2019/05/04/Hexo搭建笔记/","excerpt":"","text":"Hexo配置主要代码1. 安装Git、nodejsGit下载NodeJs下载 2.安装hexo先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。输入命令 npm install -g hexo-cli 接下来初始化一下hexo hexo init myblog 然后 cd myblog //进入这个myblog文件夹 npm install //安装npm hexo g //生成 hexo server //本地服务器测试，浏览器输入localhost:4000 3.创建个人仓库4.生成SSH添加到GitHubgit config --global user.name &quot;yourname&quot; //输入Github用户名 git config --global user.email &quot;youremail&quot; //Github输入邮箱 git config user.name //检查 git config user.email //检查 ssh-keygen -t rsa -C &quot;youremail&quot; //创建SSH ssh -T git@github.com //测试是否成功 5.将hexo部署到GitHub修改站点配置文件 _config.yml deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 接着 npm install hexo-deployer-git --save //安装deploy-git hexo clean //清除 hexo generate //生成 hexo deploy //部署 6.设置个人域名解析格式： CNAME @ 默认 yourname.github.io CNAME www 默认 yourname.github.io 博客文件source中创建一个名为CNAME文件，不要后缀，写上域名。接着 hexo c //清除 hexo g //生成 hexo d //部署 创建新的文章： hexo new newpapername 利用分支在多台电脑上操作在第一台主机上先在主分支下创建一个其他的分支，然后在这个仓库的settings中，修改默认分支。然后再任意目录git bash git clone git@github.com:yourname/yourname.github.io.git 除了.git 文件夹外的所有文件都删掉，把之前我们写的博客源文件全部复制过来，除了.deploy_git，将所有.git文件夹删去。接着 git add . git commit –m &quot;balabala&quot; git push 在第二台主机上1.安装Git2.设置git全局邮箱和用户名3.设置ssh key4.安装nodejs5.安装hexo6.进入任意文件夹克隆git clone git@……………… 然后进入克隆到的文件夹： cd xxx.github.io npm install npm install hexo-deployer-git --save 生成，部署： hexo g hexo d 写博客： hexo new newpage 写完了记得提交源文件以便同步git add . git commit –m &quot;xxxx&quot; git push 回到其他电脑上： git pull 作者整合的一些功能bilibili外链播放器语法： {% bili video_id %} 或 {% bili video_id page %} 使用方式:在Hexo博客目录使用npm安装插件 npm i hexo-tag-bili --save 在Hexo博客的文章或者单页面中使用以下标签语法插入视频 {% bili video_id %} 或 {% bili video_id page %} 例子: 如果视频网址如：https://www.bilibili.com/video/av24897960 在文章中插入的标签语法为： {% bili 24897960 %} 如果视频网址如（第二页）：https://www.bilibili.com/video/av24897960/?p=2 在文章中插入的标签语法为： {% bili 24897960 2 %} ##简易相册语法: {% fb_img src [caption] %} 使用方式:在Hexo博客目录使用npm安装插件 npm i hexo-tag-fancybox_img --save 在Hexo博客的文章或者单页面中使用以下标签语法插入图片以及描述 {% fb_img src [caption] %} 在主题文件中引入需要的css和js。一般在主题的head中引入css，footer中引入js.(考虑了很久，是不是要直接插件中渲染加入。一是做法灵活度不好，二是有些主题可能会对js等进行优化打包或者以及集成jquery，所以还是手动引入比较合适） &lt;script src=&quot;//code.jquery.com/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css&quot; /&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js&quot;&gt;&lt;/script&gt; 例子: {% fb_img https://ws3.sinaimg.cn/large/006bYVyvly1fxxewq3plij30yn0jjkjl.jpg sakura %} 加入live2d推荐作者的视频教程:手把手教你给hexo博客添加live2d看板娘hexo博客添加live2d看板娘nepgear!源文件：live2d-model网盘链接密码：7rih最后奉上作者的主题使用教程","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"开篇","slug":"开篇","date":"2019-05-02T19:53:59.000Z","updated":"2019-05-10T12:27:54.289Z","comments":true,"path":"2019/05/03/开篇/","link":"","permalink":"/2019/05/03/开篇/","excerpt":"","text":"既然是开篇，封面就用最喜欢的02啦，以后会慢慢补上画师的名字……暂时太多了很难找〒▽〒。喜欢我的图库的也可以去我的微博相册看看~全都屯在那了٩(๑&gt;◡&lt;๑)۶ 为什么开这个博客 课程作业 首先是作为学校web课程的作业了(web老师真是太好了，这学期被迫用Cocos(还没死透???)做游戏，二维动画做不好重做什么的课程真的很烦。 求职用 咳…到时候求职用的网站肯定会用其他主题，上次投网易就出现了作品只能扔B站的情况。(当然是没过啦，再努力几年吧) 写日记 开始写日记吧~今后会去多阅读一些喜欢看的书籍，会将随想记录在博客上。 个人介绍 一个平平凡凡的大三考研狗，目前就读于南京邮电大学，没错就是那个食堂能难吃得上热搜的大学(￣▽￣)／，爱好计算机图形（Computer Graphics），并可能将此作为研究生的发展方向了。 走过了许多的的弯路，大一忙于转专业，最终也没有成功。 大二开始接触离线渲染建模软件等，用剑三的模型做了一个实景合成的小视频（拍的好丑。。 大三开始有了做游戏的想法，最开始接触的是Unity，学了一个星期枯燥无味的Gameplay后转向了UE4，并在学习了一个多月后用许多商城资源尝试拼了一个很简陋的Demo： 那个时候还是挺开心的，每天去b站油管搜寻着各种教程视频，逐渐熟悉了引擎的各个模块，也加入了一些独立游戏制作的群，里面有着许多形形色色的人，有已经做过很多成功的独立游戏的制作人，有怀揣着做独立游戏梦想的30岁还没结婚的，也有和我一样刚开始学习这方面的学生. 最近的项目是一个实景漫游的学校场景，和朋友一起学习了摄影测量技术（PhotoGrammetry），制作了许多扫描的模型和贴图，在学校的科协课上安利过自己的流程（好像并没有什么人感兴趣），流程可能还在和朋友一起不断改进。 现在的方向可能还会多一个人工智能，早在大一的时候，我的父亲就推荐我去学习人工智能，那个时候的我应该说是对计算机和编程都一无所知的时候，对人工智能也并没有什么强烈的兴趣，所以走了媒体方向。感谢我的父母，从被调剂到这个专业开始，他们都一直尊重着的我的选择，大二经常与他们顶嘴不想考研，并自大的认为自己已经能够去工作了。但如今却深感时间太少，走过的弯路太多，已经不期望追上那些小学初中就开始编程或者确定自己方向的大佬们了。至少，至少再给自己争取三年的时间去学习吧，所以大三成为了一名考研狗。 感谢 感谢你能阅读到这里，如果有志同道合的朋友，十分期待能一起交流。因为平常不喜与他人交流，也不喜欢各种人多的场合，所以朋友真的很少，但熟悉的人都知道我是个逗比……..恩(；´д｀)ゞ。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"TraceYang大佬的Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 下篇","slug":"Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 下篇","date":"2018-07-28T22:20:26.000Z","updated":"2019-05-04T02:50:43.914Z","comments":true,"path":"2018/07/29/Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 下篇/","link":"","permalink":"/2018/07/29/Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 下篇/","excerpt":"","text":"查看作者原文Authored by TraceYang背景在上篇中，实现了使用Houdini在UE4里根据地形过程生成植被的最基本的原型。并且支持把植被在UE4里Bake成使用的HierarchicalInstancedStaticMeshComponent的BP形式，一定程度上解决了植被渲染效率的问题。 但这种方法在开发效率和运行效率上都还有他的问题： 开发效率方面，这个方案并不支持UE4的Foliage Mode Editor： 每个植被区域都被Bake成BP的形式，场景美术规划阶段就需要格外小心防止区域之间穿插造成植被之间的叠加 当出现比较大的改动需求时，一个BP的范围发生改动就会造成大量BP重新生成的连锁反映。 就像地形生成一样，完全的自动化并不现实，美术需要能通过UE4传统手绘方式来进行修改植被的方式。 一个区域的BP植被需要重新生成时，还要重新绘制一遍之前的生成区域，这个过程除非预先保存，否则很难完全重现上次绘制的区域。 运行效率优化方面，同一类的Instance并不能放到一个InstancedStaticMeshComponent 这样必定会造成一定程度的性能损耗正因为如此，还有必要Houdini的植被管线与UE4的Foliage Mode编辑的植被系统串联起来。这样Hoduini生成后的内容，美术可以很方便的修改，也可以用Houdini来做二次修正，最终生成的植被也可以使用UE4的植被系统的优化方案。而UE4的Foliage System，其实就是每个Level里有一个AInstancedFoliageActor，每种Foliage Type对应的Instanc Mesh实例都保存在AInstancedFoliageActor的FFoliageMeshInfo里。 如果要把Houdini过程化生成与Foliage Mode衔接起来，那么就需要Houdini Engine Input和Output部分可以支持UE4的Foliage System。也就是每个Level的AInstancedFoliageActor里，概括来说就是： Houdini Input要增加FoliageType的选项，生成实例的对象不再是用Statice Mesh，而是UE4的Foliage TypeHoudini Output直接输出植被实例不再Bake到BP里，而是直接Add到UE4的Foliage System的Foliage Instance里接下来就讲解下如何通过只修改Houdini Engine，不需要触碰UE4引擎源码，来把Houdini植被管线与UE4的植被系统整合到一起的方法。 Houdini Input对FoliageType的选项支持上篇中也提到过，原生的Houdini Engine的过程化实例放置功能，并没有把植被做特殊的Input处理，而是作为Geometry来对待。首要任务就是在Houdini Engine Input里可以支持Foliage Type。 先进入到HoudiniAssetInput.h里，在EHoudiniAssetInputType的Enum里增加FoliageTypeInput。 namespace EHoudiniAssetInputType { enum Enum { GeometryInput = 0, AssetInput, CurveInput, LandscapeInput, FoliageTypeInput, // Add foliage type input WorldInput }; } 然后，在UHoudiniAssetInput类的CreateWidgetResources()，ChangeInputType()，CreateWidgetResources()，UploadParameterValue()的函数里，参考EHoudiniAssetInputType中其他的InputType的处理方式，加入对FoliageTypeInput的处理，此外，还要在FHoudiniParameterDetails类的CreateWidgetInput，加入针对FoliageTypeInput的菜单UI，这里可以参考 InParam.ChoiceIndex == EHoudiniAssetInputType::GeometryInput 部分的代码给FoliageTypeInput实现一遍，但要自己实现一下Helper_CreateFoliageWidget for ( int32 Ix = 0; Ix &lt; NumInputs; Ix++ ) { UObject* InputObject = InParam.GetInputObject( Ix ); //Helper_CreateGeometryWidget( InParam, Ix, InputObject, AssetThumbnailPool, VerticalBox ); Helper_CreateFoliageWidget(InParam, Ix, InputObject, AssetThumbnailPool, VerticalBox); } Helper_CreateFoliageWidget和Helper_CreateGeometryWidget的区别就在与UI里对UObject子类的筛选，把UStaticMesh替换成UFoliageType SNew( SAssetDropTarget ) .OnIsAssetAcceptableForDrop( SAssetDropTarget::FIsAssetAcceptableForDrop::CreateLambda( []( const UObject* InObject ) { return InObject &amp;&amp; InObject-&gt;IsA&lt; /*UStaticMesh*/ UFoliageType &gt;(); 这样，HDA里就增加了FoliageTypeInput的选项，并添加到Input里了。这里不得不说Unity写工具界面比UE4的效率高太多了。 虽然通过修改Houdini Engine，把FoliageType的Input读入了，但是Houdini Engine的管线的实例化部分，还是只能对Geometry来进行处理，这里就需要在FHoudiniEngineUtils::HapiCreateInputNodeForObjects函数里，获取FoliageType对应的Static Mesh再输出给Houdini Input Node了。 if (UFoliageType_InstancedStaticMesh * InputFoliageType = Cast&lt;UFoliageType_InstancedStaticMesh&gt;(InputObjects[InputIdx])) { UStaticMesh* InputStaticMesh = InputFoliageType-&gt;GetStaticMesh(); // Creating an Input Node for Static Mesh Data if (!HapiCreateInputNodeForStaticMesh(InputStaticMesh, MeshAssetNodeId, OutCreatedNodeIds, nullptr, bExportAllLODs, bExportSockets)) { HOUDINI_LOG_WARNING(TEXT(&quot;Error creating input index %d on %d&quot;), InputIdx, ConnectedAssetId); } SelectInputFoliageTypeArray.Add(InputFoliageType); } 这样改造Houdini Engine后，输入FoliageType以及Landscape的Draw SelectRegion，就可以和上篇一样输出植被了。 Houdini Input支持Foliage Type后，接下来要实现的就是Houdini Output到Foliage System的功能了。 Houdini Output与Foliage Editor的关联Output与FoliageEditor关联方面最基础的需求有以下几点。 Houdini输出的Entity Point Cloud所对应的Instance可以直接Add到UE4的Foliage System里。美术可以通过绘制区域来对已经生成部分再次做过程化生成，或者直接利用FoliageEdit手绘的方式来进行迭代调整。手绘调整部分和Houdini自动化生成部分可以分Layer保存，可以根据情况选择自动生成部分是否影响到手工调整部分。FC5里也没有提及第三项的实现方式，所以基础管线部分主要讲解前两项的实现方法，而第三条在后续文章里会参考GDC2017上GHOST RECON的地形工具的方法来实现。 这里先定位到Houdini Engine生成Output到UE4的类函数UHoudiniAssetComponent::CreateObjectGeoPartResources里 #if WITH_EDITOR if ( FHoudiniEngineUtils::IsHoudiniNodeValid( AssetId ) ) { // Create necessary instance inputs. CreateInstanceInputs( FoundInstancers ); // Create necessary curves. CreateCurves( FoundCurves ); // Create necessary landscapes CreateAllLandscapes( FoundVolumes ); } #endif 其中CreateInstanceInputs函数功能会迭代关卡里的每一种Instancer，再通过UHoudiniAssetInstanceInput::CreateInstanceInput()，根据这个Instancer对应的Cloud Point，在UHoudiniAssetComponent::CreateInstanceInputs创建InstancedStaticMesh。 for ( const FHoudiniGeoPartObject&amp; GeoPart : Instancers ) { HoudiniAssetInstanceInput-&gt;CreateInstanceInput(); } 在UHoudiniAssetInstanceInput::CreateInstanceInput()里，参考FEdModeFoliage::AddInstancesImp的方法， 在当前Level的AInstancedFoliageActor中对应FoliageType的FFoliageMeshInfo里，根据植被在Entity Point Cloud的Tranform信息，来添加Instance。 UWorld* World = GEditor-&gt;GetEditorWorldContext().World(); ULevel* TargetLevel = World-&gt;GetCurrentLevel(); AInstancedFoliageActor* IFA = AInstancedFoliageActor::GetInstancedFoliageActorForLevel(TargetLevel, true); FFoliageMeshInfo* MeshInfo; UFoliageType* FoliageSettings = IFA-&gt;AddFoliageType(FoliageType, &amp;MeshInfo); GLevelEditorModeTools().ActivateMode(FBuiltinEditorModes::EM_Foliage); FEdModeFoliage* FoliageEditMode = (FEdModeFoliage*)GLevelEditorModeTools().GetActiveMode(FBuiltinEditorModes::EM_Foliage); for (int32 InstanceIdx = 0; InstanceIdx &lt; InstancerPartTransforms.Num(); ++InstanceIdx) { FTransform InstanceTransform; FHoudiniEngineUtils::TranslateHapiTransform(InstancerPartTransforms[InstanceIdx], InstanceTransform); FFoliageInstance Inst; Inst.Location = InstanceTransform.GetLocation(); Inst.Rotation = InstanceTransform.GetRotation().Rotator(); MeshInfo-&gt;AddInstance(IFA, FoliageSettings, Inst, nullptr, true); } 如下图所示，过程化植被也加入到了Level的AInstancedFoliageActor里。这样生成后也可以使用Foliage Editor来做二次修改。 当场景美术需要做二次修改时，那么首先需要把修改区域的植被先清除掉，再使用Houdini对这块绘制区域重新过程化生成植被。这就需要Houdini Engine可以支持移除掉绘制区域植被的功能。这个可以参考void FEdModeFoliage::ReapplyInstancesForBrush的方法。使用MeshInfo-&gt;InstanceHash-&gt;GetInstancesOverlappingBox来获取美术绘制范围的Instance，在利用MeshInfo-&gt;InstanceHash-&gt;RemoveInstance把范围内对应的Foliage Type移除，再使用HDA来重新生成。在上一篇中我们也讲到Select Tool其实绘制的是地表的Mask，也就是对应地形Tile的X,Y值，所以这里还需要把Landscape的X,Y值转成世界空间的Box，来做判断，这部分的实现代码如下： ULandscapeComponent* SelectLandscapeComponent = FHoudiniLandscapeUtils::SelectLandscapeComponentArray[Index]; int32 MinX = MAX_int32; int32 MinY = MAX_int32; int32 MaxX = -MAX_int32; SelectLandscapeComponent-&gt;GetComponentExtent(MinX, MinY, MaxX, MaxY); ULandscapeInfo* LandscapeInfo = SelectLandscapeComponent-&gt;GetLandscapeProxy()-&gt;GetLandscapeInfo(); for (int32 X = MinX; X &lt;= MaxX; X++) { for (int32 Y = MinY; Y &lt;= MaxY; Y++) { float RegionSelect = LandscapeInfo-&gt;SelectedRegion.FindRef(FIntPoint(X, Y)); if (RegionSelect &gt; 0) { SelectRegionNum++; FBoxSphereBounds ComponentBounds = SelectLandscapeComponent-&gt;CalcBounds(SelectLandscapeComponent-&gt;GetComponentTransform()); FBox CachedLocalBox; CachedLocalBox.Min = FVector(X, Y, 0); CachedLocalBox.Max = FVector(X+1, Y+1, 0); CachedLocalBox.IsValid = 1; FBox MyBounds = CachedLocalBox.TransformBy(SelectLandscapeComponent-&gt;GetLandscapeProxy()-&gt; GetLandscapeActor()-&gt;GetActorTransform()); MyBounds.Max.Z = ComponentBounds.GetBox().Max.Z ; MyBounds.Min.Z = ComponentBounds.GetBox().Min.Z ; FBoxSphereBounds RegionBounds = FBoxSphereBounds(MyBounds); auto TempInstances = MeshInfo-&gt;InstanceHash-&gt;GetInstancesOverlappingBox(RegionBounds.GetBox()); for (int32 Idx : TempInstances) { if(InInstancesToRemove.Find(Idx) == INDEX_NONE) InInstancesToRemove.Add(Idx); } } } } MeshInfo-&gt;RemoveInstances(IFA, InInstancesToRemove, true); 迭代SelectRegion的每一个绘制点，把这个绘制点根据地形世界变化转换为对应的Box，再判断Box里是否有Instance，再进行移除操作。如果是基于Landscape Component做再生成就简单很多了，获取这个Component的Box，移除掉Box范围内的植被实例。 分步的看一下修改改后的效果。首先Houdini Engine会把绘制区域的植被全部清除掉。 然后再根据HDA里的Scatter算法，来摆放Instance并加入到关卡的AInstancedFoliageActor里。 之前的代码示例只是移除其中一种FoliageType，如果需要删除掉绘制区域的所有Foliage Type的话，只需要迭代每个FoliageType对应的FFoliageMeshInfo，再进行删除Instance操作即可。 TMap&lt;UFoliageType*, FFoliageMeshInfo*&gt; InstancesFoliageType = IFA-&gt;GetAllInstancesFoliageType(); for (auto&amp; MeshPair : InstancesFoliageType) { FFoliageMeshInfo* MeshInfo = MeshPair.Value; UFoliageType* FoliageSettings = MeshPair.Key; } 就此，一个最基本的Houdini驱动的UE4植被系统的FoliageType部分就完成了。而一些具体的细节改动和工具开发，会放在内容制作部分再做讲解。 GrassType的对应上一节也讲到，UE4的植被系统除了Foliage Type外，还有Grass Type,Grass Type除了没有碰撞外，保存和生成方式也不一样，Foliage Type的植被是制作阶段就保存在AInstancedFoliageActor里，在游戏运行时跟随Level加载后作为Instance来渲染。而Grass Type虽然也是跟Foliage Type一样，使用的HierarchicalInstancedStaticMeshComponents来进行渲染，区别在于它是在游戏运行时根据相机的视角来生成的。而GrassType的分布信息，则是根据UE4的地形材质系统来输出的。就如下图所示，默认的哪种GrassType被布置地面的哪个位置，是通过采样Landsacpe Layer的信息来确定的。但这种方式就导致了Grass和Layer之前的强制绑定关系。在一些特殊需求上，比如在一些特定的地标区域生成某种特定的草，或者排除掉某些特定草的需求，使用默认的方案都很难解决。 一种折衷的方案，是像下图这样，自己输入一张全场景的植被布局Mask图，来作为GrassType的采样信息使用，但这受限于植被的种类，地图大小，很难保障精确，只能作为临时的方案。 还有一种方法就是直接改引擎源码，void ALandscapeProxy::UpdateGrass(const TArray&amp; Cameras, bool bForceSync)的部分。这个就不是光修改Houdini Engine引擎就能解决的了，文章篇幅关系也只能放到后文单独挑出一章节来做讲解。 总结至此，地形和植被相关的整个管线部分已经基本上打通，但和国外AAA级产品的过程化工具比，还是有很大的差距。 管线上的主要的差距还是在工具易用性和完善程度上，比如幽灵行动：荒野里，通过把过程化生成的地形，道路，铁路，以及手工修改的部分做分层保存，这样当一层做修改或恢复时，才不会影响到其他的层的修改。 后续的文章中，会逐步的深入到具体的场景地形和植被制作上，届时也会涉及到更多Houdini Enigne管线修改的细节上。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 上篇","slug":"Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 上篇","date":"2018-07-27T22:20:26.000Z","updated":"2019-05-04T02:50:43.289Z","comments":true,"path":"2018/07/28/Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 上篇/","link":"","permalink":"/2018/07/28/Houdini技术体系 基础管线（四） ：Houdini驱动的UE4植被系统 上篇/","excerpt":"","text":"查看作者原文Authored by TraceYang背景之前在《Houdini技术体系 过程化地形系统（一）：Far Cry5的植被系统分析》一文中已经对AAA游戏中过程化植被的需求有了一定的定义，后续工作就是如何用Houdini开发功能需求定义的节点，以及对应UE4的Houdiin Engine来制定过程化管线。Houdini的HDA的开发放在过程化地形系统部分讲解，这里主要是讲解工作流程的制定。FC5的分析之前，也大致介绍了UE4的植被系统。这里再确定下植被系统工作流方面的需求： Houdini Input：UE4 要输入什么给Houdini 所选择Landscape Component部分的地形信息 美术提供的选择区域，可以是绘制的Mask，也可以是Curve的选框 与HDA中对应的植被资源参数，简单的可以用Houdini Engine ，完善一些的话最好是一个json或xml的描述文件，或者UE4的DataTabel。 除了HeightMap外的Mask信息，还有峭壁，湖泊，电线杆，栅栏等不能摆放植被的区域Mask Houdini Ouptut：Houdini要输出什么给UE4 Entity Point Cloud：每个点包含了对应的植被实体，以及实体的Positon，Rotation，Scale等Transform信息 Terrain Data：例如树根对地形隆起的变化，树根部分对地表材质Mask的影响，地表的颜色等 Mask Data：草体布局信息的Mask贴图 UE4植被系统的支持 Houdini Instance与UE4 Foliage Type的Instance的对应 Houdini Biome Mask与UE4 Grass Type的对应 Houdini闭环修改与UE4 Foliage System的对应。 那么，这里就以实现这些需求为目标，介绍下实现基于Houdini的UE4植被系统的基础管线所要注意的事项。 Houdini的Input设置在之前FC5的植被系统的需求分析中也可以得知，最新的AAA游戏中，一平方公里场景里就有60w左右的植被实体，而最近的一些UE4大世界游戏和手游，也通常在6x6~8x8km左右。在策划和美术的迭代开发中，每次都要生成整个场景的植被再看效果的话，会极大的影响开发效率，对大团队的多人协作开发也很不友好。所以这里也要像之前的地形管线一样，以FC5的过程化系统为原型，可以支持美术或策划来选择和绘制生成区域，让Houdini的过程化生成只影响这一部分选择区，这样不但可以利用UE4的WorldComposition的功能多人工作，也可以通过UE4自带的绘制Selection Region Tool，让美术更进一步的控制过程化的影响区域，减少生成时间，提升迭代效率。 如下图所示，FC5的植被系统，支持类似UE4的Component和Paint Region来作为Terrain Data， 在上文中，也总结到UE4里FC5植被系统的Input，有以下几项： 所选择Landscape Component部分的地形信息 美术提供的选择区域，可以是绘制的Mask，也可以是Curve的选框 与HDA中对应的植被资源参数，简单的可以用Houdini Engine ，完善一些的话最好是一个json或xml的描述文件，或者UE4的DataTabel。 除了HeightMap外的Mask信息，还有峭壁，湖泊，电线杆，栅栏等不能摆放植被的区域Mask 关于如何确定Input Terrain Data，Landscape Component的选择在地形管线部分已经几次讲到了。幸运的是，UE4除了Component Select Tool之外，在Terrain Sculpt Tool里提供Region Selection Tool的功能，这个要比Component Select Tool更加灵活和便捷。但和Component Select Tool一样，这个功能对原生的Houdini Engine并不适用… 如上图所示，Region Selection Tool是Terrain Sculpt Tool里的功能，不过可以借用这个功能来作为Input的Mask Paint来使用。接下来看下怎么扩展Houdini Engine把这个Mask作为Input传到Houdini里去。 Region Selection Tool绘制的Mask的方式，当使用者绘制时，会在FLandscapeToolStrokeMask::Apply函数里根据笔触和权重值，把绘制值添加到class ULandscapeInfo的TMap&lt;FIntPoint,float&gt; SelectedRegion 里的，只有绘制过的区域才会保存在SelectedRegion里，其中FIntPoint代表的是在Landscape里的XY位置信息，作为整型保存，而float为绘制Mask的权重。 拿到了SelectedRegion后，就是要在Houdini Engine里把它作为Mask，输入到HDA中进行处理。Houdini Engine是在FHoudiniLandscapeUtils::CreateHeightfieldFromLandscapeComponent函数里对Height Data和Mask Data进行Input打包的，这里选择在这个函数里加入SelectedRegion的Mask的打包工作。 首先，是根据Houdini里一个Landscape Component的大小MaxX x MaxY，创建出对应的SelectedRegion大小的Mask数组。在LandscapeInfo的SelectedRegion里查找每个点的信息，如果有就复制到对应位置，没有则设置为0。这样，提供给Houdini使用的SelectedRegionData就完成了。 TArray&lt;float&gt; SelectedRegionData; for (int32 X = MinX; X &lt;= MaxX; X++) { for (int32 Y = MinY; Y &lt;= MaxY; Y++) { float RegionSelect = LandscapeInfo-&gt;SelectedRegion.FindRef(FIntPoint(X, Y)); SelectedRegionData.Add(RegionSelect); } } 接下里，跟LayerMask同样的方式，通过C++代码创建一个名为SelectedRegion的Mask节点，并跟其他的Volume Merge到一起。 FString LayerName = &quot;SelectedRegion&quot;; HAPI_NodeId LayerVolumeNodeId = -1; if (!CreateVolumeInputNode(LayerVolumeNodeId, LayerName, ParentId)) return false; HAPI_PartId CurrentPartId = 0; if (!SetHeighfieldData(LayerVolumeNodeId, CurrentPartId, SelectedRegionData, SelectedRegionLayerVolumeInfo, LayerName, ComponentIndex)) return false; if (!CommitVolumeInputNode(LayerVolumeNodeId, InputMergeNodeId, MergeInputIndex)) return false; MergeInputIndex++; 另外，ULandscapeInfo提供了把绘制的SelectedRegion转为Selected Component的功能，这样绘制过过程化的影响区域后，就不用再选择一次Landscpe Component了。这个修改也很简单，在FHoudiniEngineUtils::HapiCreateInputNodeForLandscape函数里，当没有selected components时，就把绘制的区域转换成SelectedComponents。 if ( LandscapeInfo ) { // Get the currently selected components SelectedComponents = LandscapeInfo-&gt;GetSelectedComponents(); // 如果没有selected components，则从绘制区域获取selected components if (SelectedComponents.Num() == 0) SelectedComponents = LandscapeInfo-&gt;GetSelectedRegionComponents(); } 把名为“SelectedRegion”的Mask作为Input输入到HDA后，需要在HDA里对应这个Mask Layer来识别。在HDA的Heightfield Noise节点里，把SelectedRegion作为Mask Layer来使用 这样HeightField只有在有Mask的部分会有Noise的效果，这个同样也可以用在植被的Entity Point Cloud的生成上。 下图的效果，就是在绘制的’X’的区域内，对9个Landscape Component产生噪声变化。 绘制选区通常是控制比较大的区域，而如果是要生成小范围的区域，建议像下图这样用Curve Input来控制区域了。 如何创建一个Curve Input的方法，在Houdini技术体系 基础管线（三） ：UE4以选择区域的方式对地形做生成和更新 上篇 和官方文档 https://www.sidefx.com/docs/unreal/_curves.html里都有详细介绍，也是有创建SOP或添加Operate Path两种方法。这里就不多做叙述了。 除了HeightData选区外，Input还需要有摆放的UE4植被列表（Biomes List），植被列表通常是用xml，json，或者ue4的datatable来记录每种植被在HDA节点里属性以及在UE4中使用资源的对应关系。然后在HDA里通过Python脚本来加载读取，即便是比下图FC5用例更复杂的HDA节点串联和配置，也可以借助Python自动化，完全摆脱人力基于配置文件自动化的创建和连接。Houdini的Python脚本使用在后续的基础管线部分讲解，本节出于篇幅关系，使用Geometry Input作为简化版的Biome Input。 而类似各种像湖泊，峭壁，电线杆等的Mask过程化生成的Mask，这里假设你已经通过其他方式导出了Mask图，或者准备在Houdini里通过Mask By Feature或Mask By Object来生成。在管线部分也就不浪费篇幅了，会在之后具体的地形篇的植被制作部分再做详细介绍。 HDA的制作以及Ouput的对应FC5的HDA的Output分为两大类 Entity Point Cloud Terrain Data基于Input生成Entity Point Cloud的原理非常简单，在去年的在 Houdini HIVE at SIGGRAPH 2017上，Procedural Scattering in Houdini Engine and Unity 的Talk上介绍的就涵盖了全部的基础知识。就如下图所示，根据Terrain，Curve以及资源实体的Inptu，按一定规则在引擎里进行过程化摆放。 视频链接：https://vimeo.com/228231127 ，对应hda的下载地址：https://www.dropbox.com/s/iv840ldw5tn4lw1/scatter_tool.hda?dl=0 。虽然跟FC5的实现相比还有不小的差距，在管线篇中作为基础参考绰绰有余，有兴趣的可以下载来看看。这里也借用它简单介绍下使用的相关节点和功能。 下图中，Setup中的三个Input，分别对应的Terrain Data，Curve Select和Biome Instance。 这里先创建个临时的Terrain和Curve来做测试使用。 结果就是在Curve选择范围的Terrain上，随机Scatter了一定数量的Entity，这里用红色的Box作为代理体显示。 这里参数不变，把scatter换成heightfield scatter 这样，只有绘制了Mask的红色区域才会被放置Entity。 但是示例的这个Scatter Tool也有不适用的地方。首先就是把物体赋予到Entity Point Cloud的Copy节点，并不能对应UE4的Instanced Mesh，这样Output到UE4里的话，每个树木实体都会创建为一个Static mesh，会让过程化生成和最后运行的效率都变得非常差。最好映照按照官方文档的建议，用支持Instance的Copy to Point节点替换掉Copy Stamp节点。 这里根据地形坡度生成mask，然后把Mask转为Point Cloud来摆放树木，来比较Copy to Point节点和Copy Stamp节点的区别。 这里使用heightfield_mask by feature，取出Slope为20~70范围的Mask。在一块小的地形上生成100颗树来对比下生成效果。 首先是用Copy Stamp节点，选择好地形和植被实体后，经过20~30秒的卡顿后，有90多个植被生成出来。这个生成的时间和植被数量比，使用体验很难让场景美术接受。 不论是Bake成BP还是Actor，所有的树都会被Batch成一个Static Mesh，这样对图形程序做植被渲染优化也非常不友好 和Copy Stamp那20多秒的处理时间相比。。替换为Copy to Point节点，在选择完Input的植被实体和地形后的瞬间（1秒内），几乎没有感觉到任何延迟的，就完成了100颗树木实例的摆放工作。 把植被Bake成一个BP后，可以看到所有的树木被Bake到一个Instanced Static Mesh组件里，而每颗树作为一个Instance保存。也正是因为它采用的Instance的方式，才会有那么快捷的生成速度。这个效率对场景美术迭代来说足够了，但InstancedStaticMesh并不支持LOD模式，用来批量放置的植被实体原有的LOD信息也丢失了。这里应该是创建HierarchicalInstancedStaticMeshComponent才能支持LOD。 如何生成HierarchicalInstancedStaticMeshComponent的Actor或BP，可以参考 void UHoudiniAssetInstanceInputField::AddInstanceComponent( int32 VariationIdx )的函数。当Static Mesh有多个LOD时，Houdini Engine会用HierarchicalInstancedStaticMeshComponent替换Instanced Static Mesh UInstancedStaticMeshComponent * InstancedStaticMeshComponent = nullptr; if ( StaticMesh-&gt;GetNumLODs() &gt; 1 ) { // If the mesh has LODs, use Hierarchical ISMC InstancedStaticMeshComponent = NewObject&lt; UHierarchicalInstancedStaticMeshComponent &gt;( RootComp-&gt;GetOwner(), UHierarchicalInstancedStaticMeshComponent::StaticClass(), NAME_None, RF_Transactional); } else { // If the mesh doesnt have LOD, we can use a regular ISMC InstancedStaticMeshComponent = NewObject&lt; UInstancedStaticMeshComponent &gt;( RootComp-&gt;GetOwner(),UInstancedStaticMeshComponent::StaticClass(), NAME_None, RF_Transactional ); } 这里保证树的实体有LOD，并且在HDA Input 勾选Export LODs 再次Bake，可以看到是HierarchicalInstancedStaticMeshComponent，每个Instance也有之前的LOD信息了。 姑且算是支持了最基础的Entity Cloud Point的Output，但距离实际项目需求还很遥远，就像Input需要支持Biomes List配置表的读取一样，Output出于维护和调试的考虑，最好也是能支持Biomes List的输出，而且，虽然提供给场景美术绘制影响区域的功能，但BP的保存方式，对Houdini的闭环迭代也并不足够的友好，当美术需要对一些细小地区做频繁迭代时，新生成的植被如何去替换BP里已经生成植被也是个问题，解决方法只能整个BP对应区域重新生成一次。这需要美术在设计初期就对植被布局策略和种类考虑清楚。还有就是UE4除了Foliage Type外，还有Grass Type的植被的支持。这些会放在之后如何UE4植被系统整合的部分来讲解。 FC5的植被系统除了Entity Cloud Point之外，还有以下的Terrain Data的Output。 其中Terrain HeightMap和Forest Mask，都可以通过之前地形管线中介绍的方法传递给UE4，而Texture ID，因为FC5的地形渲染有TextureArray支持，而UE4则受限于每个Component4个Landscape Layer的限制，所以Layer与Texture的对应又是在Mateiral里绑定的，需要修改UE4引擎源码才能支持，但这就超出Houdini技术体系范畴了。这里介绍一个临时的折中办法，通过直接去修改约定好的对应的Layer的Mask权重的方式，来实现UE4里要根据输出的Houdini Output的去改变Layer的Texture ID的需求。 首先，用RegionTool绘制一块区域来生成植被 这里就只简单的根据绘制的Mask部分Scatter生成Point Cloud，效果如下 接下来实现一下Terrain Data的Output的功能，不论是Terrain Texture还是Terrain Deformation的输出原理上都是在植被一定范围内生成Mask，再把这个Mask转化为Layer Data或者Height Data，传递给UE4。 出于跑通管线的目的，这里在HDA里做一个简单的实现。在houdini里根据Scatter生成的Point Cloud，使用Sphere来生成出Mask，再根据这个Mask来提升地形高度，并把Mask输出位树根部所对应的Landscape Material Layer的值。 在测试场景上选择一个生成区域 有摆放植被的周围地形改为了另外一种Layer。 树根附近的地表高度也被提升了。和FC5那种按照树根形状来提升高度的效果相比还是有差距。 总结上篇中，简单的介绍了如何在UE4里实现类似FC5植被系统的管线，但还有问题等待解决 虽然植被实体可以被Bake为HierarchicalInstancedStaticMeshComponent或InstancedStaticMeshComponent来近似UE4Foliage Type的渲染方式，但并不支持GrassType的类型。Point Cloud生成的植被只能Bake为场景中的Actor或BP而不是Foliage Type，并不能与UE4的Foliage System融合，在迭代和修改中增加了额外的负担。示例中的HDA只支持1种植被，生成策略也非常简单，而且也不支持BiomeList的读取，和FC5有相当大的差距。 对于前两点，会在Houdini驱动的UE4植被系统 下篇中有进一步解决方案的介绍，只有整条UE4的植被基础管线完成后，才能把鱼FC5近似的Houdini功能集成到UE4里，这部分HDA的制作会在地形系统篇中进行具体讲解。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 过程化地形系统（二）：基于UE4植被系统（1）","slug":"Houdini技术体系 过程化地形系统（二）：基于UE4植被系统（1）","date":"2018-07-25T22:20:26.000Z","updated":"2019-05-04T02:50:44.966Z","comments":true,"path":"2018/07/26/Houdini技术体系 过程化地形系统（二）：基于UE4植被系统（1）/","link":"","permalink":"/2018/07/26/Houdini技术体系 过程化地形系统（二）：基于UE4植被系统（1）/","excerpt":"","text":"查看作者原文Authored by TraceYang背景通过之前的几篇分析实践，已经基本打通了UE4的Houdini植被管线部分，并对Far Cry5（简称FC5）的植被系统的需求做了整理，在接下来的几节中，会关注于如何使用Houdini基于UE4来开发类似FC5的植被生成系统。这里按工具制作流程分为几个部分来做阐述。 1.使用Houdini开发类似FC5里的Generate_Terrain_Entities的HDA节点2.修改Houdini Engine，让Generate_Terrain_Entities的Input和Output可以支持在UE4里生成植被3.进一步优化Houdini Engine，可以让关卡设计人员可以在UE4 Editor里更加灵活和方便的修改 本节的目标就是如何开发一个Generate_Terrain_Entities的HDA节点，并在Houdini里实现类似上图中FC5的效果，大致流程分为： 创建HDA面板，为内部的过程化实现创建参数关联 根据Viability中选择Terrain Data以其他的过程化生成的2D data，确定植被的生成范围 根据Density，Sizes，Scale，Color，Rotation等面板参数，来生成Point Colud，以及Point对应的旋转，颜色，缩放等信息。 多个HDA连接，每个HDA代表一种植被类型。并实现按照Viability范围和优先级的选择正确的Species。 根据最终的PointCloud，用Copy to Point节点做植被的Instance化面板制作首先要做的，是创建一个Generate_Terrain_Entities的SOP节点，并且HDA的参数面板和Input/Ouput，这里先创建一个SOP节点， 参考FC5，创建一个类似的Generate_Terrain_Entities的参数面板和Input，Output的输出。 参数面板就和FC5文档里介绍的一样，具体做法就不多做叙述了，稍微有些Houdini经验的美术都可以实现。 参考FC5把Input Laber 设置为2个，Output为3个，Input Output接续的数据在下图有注释。这样把每个Speices链接链接在一起，具体如何起作用的在后文会有介绍。 复制完参数面板后，就是要实现根据参数来生成植被的Point Cloud信息的功能了，在之前管线里已经提到过，Point Cloud是使用Scatter节点，基于Heightfiled Mask的信息来生成的。接下来的目标就是如何根据植被系统的设置，正确的生成所对应的Mask。 确定生成区域FC5的植被系统的生成区域来源主要是两部分，一个是基于地形数据生成的各种Mask数据，例如AO，Flow，Slope，这些Mask通常确定植被会生长在哪些区域， 另外一种就是直接导入的2D数据，比如场景美术手绘的区域，以及一些在引擎里通过其他的过程化工具生成内容，比如街道，水塘的Mask，保证这些区域不会有植被放置。 把这不同Mask的组合根据规则和面板参数做数学组合，就得出最终的生成区域结果，这里简单的介绍下如何使用VEX脚本结合Houdini的节点来实现功能。 首先是AO，Flow，Slope，Direction（Sun or Wind）等Terrain Abiotic Data的生成，这些大部分可以用Houdini自带的节点来生成 AO的生成，这里使用官方论坛上的一个OpenCL加速的heigtfiled AO节点，链接地址：https://www.sidefx.com/forum/topic/54318/?page=1#post-243847 Altitude可以直接读取height信息，但因为一些特殊的缘故，height的最低值并不一定为0，这里使用了一个Python节点，调用terraintoolutils.computeInputRange的函数来获得height的范围 这里增加一个altitude的Attribute的Ramp，用来获取制定范围内的高度信息 在Generate_Terrain_Entities内部，在名为Mask的SubNetwork里主要做这些各种Mask的处理工作 这个示例Vex代码里，迭代每一个Attribute的Ramp的Mask，然后合并到一起。为了简化有些功能没实现到Vex里，比如每个Attribute的Toggle开关和Power值的判断，不同的Attirbute，例如Altitued还要做一些特殊处理等等。另外FC5可以支持多组Combined Data后的Data Group再做二次Combine。最终会是双重循环的形式。 下图的效果就是只有一个Altitude（Height） Attribute的效果。 接着，在单独加入一个Slope的Attribute的效果 最后得到两个Attribute合并的效果。 这样，houdini的生成区域的基本功能就完成了，后面就可以参考FC5，基于flow，direction等信息，制作出不同的植被生成区域的pattern 除此之外，FC5中还有一些用过程化工具生成mask要做为exclusion区域来使用 比如这里把生成water的区域，作为exclusion mask。 把exclusion mask作用到Alittude Attribute上， 原始的altitude attribute中加入water attribute 就得到了exclusion后的结果。 除此之外还有Noise，FC5的Noise的Size是受地形法线影响的，这根据Volume中height的位置，来取得height mesh里对应的Point的Normal，根据Normal的Y值来控制生成Noise的Size。 这样，不同坡度的噪声大小也不同。下图就是water和altitude attribute以及noise共通作用的结果。 最后得到的Mask，就是对应的植被生成区域。接下来就要根据Mask，来生成植被的Scatter Point Cloud了。 生成Point Cloud基于HeightFiled Mask来生成Point Cloud，通常使用HeightField Scatter就可以实现 而FC5的植被系统里，还是要考虑植被的Size和Age参数，来确定最终的Point Cloud，这里使用下面两个Attribute的Data Group来作为植被的生成信息 下图就是得到的Viability的信息。 接下来，需要把Viability Mask用SDF的方式转为Age的mask 通过convertvolume和isooffset节点，用SDF方式重新生成Age Mask 接下来，通过Density面板，来配置密度，然后把Density写入到HeightFiled的Mask里（也可以自己新建一个volume来保存）。而通过Density Ramp来控制不同Size植被的密度值，也就是Age（Mask）越小的外围的小树，密度越高，而Age（Mask）比较大的树林中心的大树，密度会比较小。 把Density值作为Density Attriube传入到Scatter节点，同时输出Point的Radius属性。 这样就得到了初步的Point Cloud，以及对应Point的Size，Pscale的信息。 然后，通过Size面板，设定不同等级的植被的具体大小。 以及对应的植被的颜色值。 就得到了带有具体Color和Transform信息的Point Cloud. 再通过Copy to Point节点，用Debug Tree进行测试，这样就得到了一种植被的Scatter结果。可以看到Age信息外围颜色较浅的树木密度相对较大，尺寸也较小，而Age信息内部的颜色较深的树木则尺寸比较大，散布的也相对稀疏一些。 这样，一种植被的生成功能已经初步完成，但生态系统里，还是要考虑多种植被的共通生长的竞争关系。以及同一种植被之间的竞争关系。这就需要实现FC5里通过对Viability Radius的判断来选择Species的功能。 根据Viability选择SpeciesFC5使用的方法，是根据Viability Radius和Viability强度，来确定一个范围内生成哪种植被。 这个实现也比较简单，先获取一个Point Radius范围内的全部Point，把Viability相对较小的剔除掉就可以了。 这样，在之前的演示的植被效果下面，再增加一个HDA节点。生成Species B Species B的生成信息如下。 这里Species B的Viability值比Species A要高 这样，Species B和Species A混合在一起后，Species B会把Viability Radius里的Species A剔除掉 增加密度后，2种植被的布置效果。 最后像FC5这样，把地貌的生态环境中的每种特定位置的植被用HDA文件一一描述再串联起来，就可以构成区域复杂的植被体系了。 总结这样，就初步实现了FC5的Generate Terrain Entities的基础功能，但欠缺的地方还是很多的。 Density，Size，Age等参数使用以及规则上，需要去对应最终的游戏世界的尺寸做修改。 如何更优雅的与UE4的FoliageSystem结合，需要再Houdini Engine里做进一步的扩展 算法上的调试，优化，也需要基于具体的制作示例来进行 像Rotation，TerrainData的输出，在之前几节有过介绍，在后文与UE4的整合里也会有进一步的改进。 在下一节里，在介绍如何使用Generate Terrain Entitie在UE4里制作效果的同时，进一步的优化和改进功能。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 过程化地形系统（一）：Far Cry5的植被系统分析","slug":"Houdini技术体系 过程化地形系统（一）：Far Cry5的植被系统分析","date":"2018-06-30T22:20:26.000Z","updated":"2019-05-04T02:50:44.455Z","comments":true,"path":"2018/07/01/Houdini技术体系 过程化地形系统（一）：Far Cry5的植被系统分析/","link":"","permalink":"/2018/07/01/Houdini技术体系 过程化地形系统（一）：Far Cry5的植被系统分析/","excerpt":"","text":"查看作者原文Authored by TraceYang背景在大世界游戏里，植被（biome）是自然环境非常重要的组成部分，虽然UE4里的也有比较不错的地形+植被系统，但相比国外AAA级游戏的效果，还是有不少的差距，简介如下： UE4的植被分为（Folige Type）和（Grass Type），都是通过HierarchicalInstancedStaticMeshComponent来进行实例渲染，但生成方式不同 Folige Type可以带有碰撞信息，通过Foliage Paint tool或Procedural Foliage Volumes 预先生成和放置，再跟随场景读取时加载。 Grass Type自己不带碰撞，根据所在的Material Layer和设置预生成密度图，在运行时根据摄像机来生成视野周围的Grass。 两种方式在摆放上都会有不少的限制 当一块地表上出现多种Foliage或Grass时，还是会产生不同类型植被之间的竞争和重叠的情况 Folige Type在特别是石块，树木，草体都存在的情况下，增减修改都会变的很麻烦 布局上还是要人为的控制，一旦场景地形要修改，就要重新各种刷新或配置Foliage Type，Grass Type也要跟着刷Material Layer来改变。 Procedural Foliage Volumes可以一定程度上减少Paint的工作量，但可控的参数过少。 所以植被的过程化系统无论是表现上，性能上，还是迭代的便利性上，都是非常重要的部分。近两年GDC上，Ubisoft在Tom Clancy’s Ghost Recon: Wildlands和Far Cry 5（后简称FC5）的过程化植被生成上都有不错的分享。这里我把Houdini的植被系统实现分为三部分来分享，在基础管线部分主要是Houdini的植被系统与UE4的植被系统如何做衔接，过程化地形部分本节先会分析FC5的实现机制，下一节介绍如何在Houdini和UE4环境下实现类似功能。 Far Cry 5的植被系统概述 植被的分层结构：每个地块有一个生态组（Main Biome），而主生态组又包含若干的子生态组（Sub Biome）。FC5里把一个Sub Biome结构称为Recipes，每个Recipes由代表不同的区域和种类来命名，比如biome_moutiain_forest，代表的是山上的树林。而一个Recipes里则是若干个Species组成，每个Species代表的是Recipes对应区域和生态里一个植物或物件种类的生成。 Houdini与分层的联系：每个Species其实都是一个Generate Terrain Entities的Houdini HDA节点，把HDA节点一个接一个的连在一起组成Recipes（Sub Biome），而所有的Recipes再连接在一起成为一个Main Biome。每个HDA可以读取地形Mask信息和它的配置参数，输出自己对应的植被的摆放信息，而连在后面的HDA会根据前面HDA留下的信息，通过HDA内置的参数和算法，确定是否会覆盖前一个HDA的生成信息。 地形数据信息：根据地形的高度信息，生成不同的Mask信息，以及用户手绘的数据 包括Occlusion，Flow，Slope，Curvature，Illumination等通过高度生成的信息，以及海拔，经纬度，风向等人工输入的信息 湖泊，道路，栅栏，电线杆，峭壁等其他过程化生成的Mask信息也会被导出保存为2D贴图，确保植被不会生成到这些区域。 每个Speicies对应的Generate Terrain Entities都是同一个HDA节点，只是根据对应不同植被实体有不同的参数设置，除了实体摆放功能外，还可以根据摆放后的实体信息影响地形并输出到地形数据上，以及定义每个Speicies的生存能力（Viability）： Species的Entities功能 ：生成地形上特定种类的实体，包括树，灌木，花草，岩石等等 Viability ： 每种物体在根据区域有自己的生存力，以及对应的生存范围和生存优先度，来避免物件之间重叠和穿插。 Age：树木有自己的Age（年龄），根据Viability生成SDF的来决定。根据Age来控制树的高低。 Size ： 同一种类的树木有几种不同的Size，小树倾向在外围，大树倾向在中心，同一Size可以这种植被的变化（枯树等）。也可以用Age来替代Viability来控制Size Scale：在不同的Size等级之间里通过Scale来平滑过渡。 Color： 每个植被实例可以根据地形或自身属性来改变的颜色变化，比如通过水体的SDF来控制草体 - Species的颜色。 Density：树木密度，可以根据树的大小设置不同密度。 Rotation：根据地形坡度，水源信息以及风力来改变草体的旋转和方向。 Transform ： 没有特意讲到，应该就是Transform信息 Group ： 同样没有特意讲到，可能就是Houdini的Group信息。 Species的写回Terrain功能 : 布置的资源也可以影响到地形的信息。 Terrain Color：地表植被信息可以给予地形贴图一个Tint Color，这个颜色也会通过shader影响到代表上草体的颜色，在地形贴图有限的情况下增加变化。 Terrain Textures ： 输出树根部分的贴图ID，以及混合系数，配置到Terrain Material的 - - Layer Texture上，做到地表和树根的融合效果。 Terrain Data Output ： 可以把Species的数据包装输出，比如把Age或Viability写入到一个属性，再由后面的Species读取。Terrain Deformation：植被信息会影响到地形HeightMap的变化，比如树根部分会让周围地表隆起。 整个FC5 Biome的核心就是这个名为Generate Terrain Entities的HDA节点。 输出到编辑器：所有实体的信息会以Entity Point Cloud的方式输出到引擎编辑器，每个Point除了位置信息属性，还有对应的实体实例引用，以及前面提到的HDA中生成的类似Size，Scale，Color等信息传送到编辑器，编辑器里再根据这些信息在场景里生成对应的资源。 所以，要实现FC5类似的植被系统，Houdini和UE4里需要做的功能主要有： 根据地形的HeightData生成各种Mask信息，以及其他过程化工具生成Mask的回读功能 类似Generate Terrain Entities里的HDA功能 HDA所生成的点云和Terrain信息回读到UE4里改变之前的配置本节会先对FC5的文档做需求分析，在下节提供具体的Houdini的实现方法。基础篇里涉及如何在UE4里把HDA输出的数据运用到场景里。 地形数据生成上文提到，过程和生成Biome使用的地形数据主要来源有以下两个部分： 在Houdini里基于Heightmap生成 游戏编辑器中输出的2D Mask数据基于Heightmap生成各种特性Mask的功能，在使用WorldMachin做地形时就经常被使用，Houdini作为WM的替代品也有对应的节点。使用这下图这3个节点，或者基于他们的内部实现自己整合一个节点就可以生成Occlusion，Flow，Slope，Curvature，Illumination等信息了。 而像在编辑器里过程化生成的湖泊，电线杆等信息，就是设置一个公共的资源目录保存对应的Mask，在每次编辑器里调用过程化工具生成时，使用Python脚本加载对应Mask图，使用Mask By Object节点生根据场景成Mask，再用Python把过程化场景的信息作为Mask保存起来。或者是把每次过程化生成的信息保存，然后在统一Cook时输出Mask信息到2D贴图里。 总体来说，地形数据的生成和导入，都是比较成熟技术，没有太大的难度，后面还是聚焦在植被的生成方法上。 地形的植被实体生成下图是FC5的层级结构示意 实际整个Main Biome,就像下图这样一个个的代表特定植被的Species的连接在一起。 每个Species都是一个Generate Terrain Entiies的HDA节点 接下来通过文档里HDA的截图分析需求。下图是HDA的主面板。 图上半部分是植被，地形数据列表和显示选项等，生成参数的配置在下半部分，有Entities和Terrain两个页签。里面有摆放植被和输出地形信息的功能。 ViabilityEntities页签上首先就是Species的Viability的设置，Main Biome就是大量Species节点串连起来的结果，下图的示例是两个Species串联，Viability的值则是从Terrain Attribute Data里读取的，也就是之前生成和导入的Terrain Mask。下图中SpeciesA的Viability是从Occlusion的mask取值，他的Viability值的倍数为1,而SpeciesB是从Flow Mask里做Viability的取值，Viability的值的倍数为2。并使用Ramp图标来做渐变和裁剪效果。最后途中树木的摆放效果也是因为B的Viability值比A的Viability高，所以Mask重合的部分的B树会替换掉A树。 因为SpeciesA和B在树的种类，密度，大小上并不一样，Point Cloud并不会完全重叠在一起，而是类似下图这样的分布关系，所以不能只通过的植被对应的Point的位置信息和Viability来做判断，还需要让每个Entity Point有Viability Radius，下图中，因为B的Viability值比A低，所以当他们的范围有重叠时，B的树就会被A替换掉。 此外，每个Species还有Priority和Priority Radius的设置，计算最终的摆放前，先会用Priority做比较，当Priority一样时再用Viability值做比较。 有些植被还有它特定的生存习性，地形数据除了从Heightmap计算或外部读取外，还需要可以人工的在houdini里控制生成范围，再把多个地形数据的混合出结果，例如下图得到就是在一定海拔高度范围内，沿着flow Line生长的植被Mask。也可以把之前编辑器导出或保存的例如湖泊，道路，悬崖等Mask信息导入Specie的地形数据里作为剔除Mask使用，确保植被不会生成到这些不应该生成的位置上。 通过在每Species的Terrain Attribute里增加不同的数据来混合，就可以得到类似特定位置的Sub Biomes的生成位置信息了。 Size和Scale即便是同一个Species里的同一种植被，因为生长环境和时间的不同，也会有大小（Size）的区分。自然界中，通常小树会长在树林的边缘，而大树更倾向在树林的中央。需要用Size来控制不同生长程度的植被的大小，再使用Scale增加一些随机的变化，让整个森林更加自然。下图增加了5级的Size后，虽然有了一定的变化，但还是会有阶梯状的感觉。 在Size级别之间增加了Scale后，阶梯感就消失了。 使用Size和Scale设置，有了不同比例的同种类树木后，就要想办法把合适大小（Age）树木布置到场景里。 Age如何在正确的位置摆放对应Size和Scale的植被，是通过让植被的Age与Size对应，来选择摆放多大尺寸的树木。前文也提到，自然的树林是边缘的树龄小，中心的树龄大的分布。通过面板上的Age Max Distance的值，基于Viability的Volume值收缩一定距离后再生成SDF，作为Age使用。再根据Age对Size的Influence和Age Ramp，得到对应树木的Size。 通过Age Ramp对应不同的Size的分布 Density通常是使用Houdini的Scatter设置一定的密度值，再将Viability的Mask转为Point Could。但默认的方式转换，每个Point自身没有Size信息，当密度过大，或者Scatter不同Size的植被时，很容易会出现同一种植被相互叠加的情况。所以这里要将Size转算为Density值，Size越大，Density越小。 如下图所示，Size越小，Density越大。同时也可以读取其他的Terrain Data来影响Density值。 Color地形信息也会对植被的颜色产生影响，例如读取水的SDF值，根据颜色的Ramp来对水塘附近的植被产生颜色变化。 Rotation自然界植被还会受到环境的影响，产生一定的旋转效果。比如在斜坡上的植被会沿着坡度有一定倾斜和旋转，河边的草体会更朝向水的方向，以及会受到风力的影响倾斜等等。这个在Houdini里实现比较简单。 植被对地形的输出Species HDA的另外一个功能就是可以根据植被来影响地形数据。这些功能和地形制作部分比较相似。 Terrain Defromation植被的Mask可以影响到对应地形的高度，这样可以模拟出树根隆起的效果。 Terrain Texture可以将与树根部分贴图对应的Terrain Texture ID输出给地形材质，让地形图层部分使用的贴图与树根贴图对应，而做出融合效果。 Terrain Data Output：向下图这种在黄松（Ponderosa）周围摆放石块（Rock）的效果，是后面的Rock的Species依赖前面Ponderosa Species的生成结果。 实现方式就是把Ponderosa的viability值输出，再Rock Species里再读取。 根据Ponderosa的Viability Mask Scatter得到Rock的Entity Point。 除了Viability外，也支持Age的输出。 FC5的每平方公里的场景有60w左右颗植被。整个游戏有100平方公里。 Terrain Color由于Terrain Texture总数有限制，需要根据通过地形数据生成Tint Color，在地形渲染时让Tint color作用到Terrain Texture上产生地表变化。 同样，在地表上摆放的植被的shader，也可以受到Tint color的影响。 总结通过植被系统输出下图中数据到编辑器，不但可以自动化的生成植，还可以根据植被信息进一步增强地表渲染效果。 FC5的整个植被系统的需求分析就到这里，除了一些细节功能外，Houdini方面并没有太多的技术难点，下一节，会针对UE4 Houdini Engine对应UE植被系统的管线，以及如何在Houdini里实现相关功能进行展开。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 基础管线（三） ：UE4 Landscape Component的多选支持 下篇","slug":"Houdini技术体系 基础管线（三） ：UE4 Landscape Component的多选支持 下篇","date":"2018-06-28T22:20:26.000Z","updated":"2019-05-04T02:50:46.048Z","comments":true,"path":"2018/06/29/Houdini技术体系 基础管线（三） ：UE4 Landscape Component的多选支持 下篇/","link":"","permalink":"/2018/06/29/Houdini技术体系 基础管线（三） ：UE4 Landscape Component的多选支持 下篇/","excerpt":"","text":"查看作者原文Authored by TraceYang背景上篇中，我们介绍了如何修改Houdini Enigne来设置单个Landscape Compnent的Height和Layer的数据，但原生Houdini Engine并不支持多选Component的写回功能，下篇中，我们来解决这个问题。 Component多选支持的修改Houdini Engine虽然支持多个Landscape Component的选择，但是并不支持写回到Landscape Component，需要自己来实现这个功能。单个Component的实现方法上文已经接受。 多选和单选区别只是在要把所选的Landscape Component按提交给Houdini的顺序来保存。 通过阅读Houdini Engine代码可以看到FHoudiniLandscapeUtils::CreateHeightfieldFromLandscapeComponentArray的参数LandscapeComponentArray里有所有提交的Landscape Component，不过LandscapeComponentArray中保存顺序并不是真正的提交顺序，而Houdini Engine Output出来的处理结果的顺序是Input的顺序的是一致的，如果直接用LandscapeComponentArray的结果，就会导致Component的不对应，所以这里我是在FHoudiniLandscapeUtils::CreateHeightfieldFromLandscapeComponent函数里把Input的Component保存起来，也保证了保存顺序。 然后在FHoudiniLandscapeUtils::CreateAllLandscapes函数中，就可以把每个FoundHeightfield和LandscapeComponent做对应，来调用LandscapeEdit.SetHeightData来更新这个Component的Height Data了。 for ( TArray&lt; const FHoudiniGeoPartObject* &gt;::TConstIterator IterHeighfields ( FoundHeightfields ); IterHeighfields; ++IterHeighfields ) { SelectLandscapeComponent = SelectLandscapeComponentArray[ComponentIndex]; 而Layer Data的保存方式和Height Data，所有Landscape Component的Layer都保存在一个ImportLayerInfos，比如选了4个Component，每个Component有4个Layer，ImportLayerInfos里就有4x4 16个Layer Data的信息，这里也需要自己按Component和每个Component的Layer数量来提交。下面伪代码，LayerNum为每个Component的Layer的数量，ComponentIndex为处理的Component的编号，而实际开发情况下，可能每个Component的Layer的数量和命名都不一样，那就需要根据规则来定制这里的算法了。 // Set Current Component&#39;s Layer Data for (int32 LayerIndex = LayerNum * ComponentIndex; LayerIndex &lt; LayerNum * (ComponentIndex + 1); LayerIndex++) { LandscapeEdit.SetAlphaData } ComponentIndex++; 这样修改后，Houdini Engine就可以支持多选Landscape Component的Input和Output了。这里使用上节用到HDA文件，选中4个Component做HeightField Noise的生成 但结果跟我们预想的并不一样，而且只有第一个Component被做了Noise处理。。。 这是UE4原生的Houdini Engine的Input的数据和我们的HDA的处理算法不匹配导致的。 修改HDA对Input的支持造成这个结果的原因，要从Houdini Engine生成Input的函数FHoudiniEngineUtils::HapiCreateInputNodeForLandscape入手： // 1. Create the heightfield input node. // We&#39;ll use its mergeId to connect all the landscape layers, // while it&#39;s displayId will be our connected asset ID FString LandscapeName = LandscapeProxy-&gt;GetName() + TEXT(&quot;_Merge&quot;); HAPI_NodeId MergeId = -1; if ( !FHoudiniLandscapeUtils::CreateHeightfieldInputNode( ConnectedAssetId, MergeId, LandscapeName ) ) return false; 这里是通过Houdini Engine，直接创建了一个Houdini的Merge节点，然后把每个Component的Landscape Height Data和Layer Data转为HeightField的Height和Mask Volume，在Merge到一起，也就是用C++代码来生成HDA节点，这样就保证了所有Input的整体处理，而且也可以程序化的去对应不同的Input情况，在后面的章节里，很多Input项目也是要使用C++或Python来生成HDA节点来节省开发成本。下图就是程序生成HDA节点的效果示意： 再增加一个Heightfield noise 看下效果：和之前闭环测试效果一样，因为默认的Houdini HeightField节点并不支持这种多个Volume Merge的处理。 这里介绍三种解决方法： 方法一是直接修改或重写HeightField Noise节点来支持整个Merged Volume： 方法二：用Loop处理每个Height Volume 方法三：用tilesplice把Volume合并到一起做处理，然后再用split重新切开 如果不想自己修改或定制节点的话，方法二和三都可以，感觉方法三还更省事，但方法三有以下几个问题： 一个是Tile顺序的问题。UE4里的Tile和Houdini的Tile的行列是不同的，同样一个2x2的Compnent，他的Input和Output的顺序有所不同： Input Output 1 2 1 3 3 4 2 4 这个需要自己开发功能调整，另外，方法三所选的Component也必须是NxM这种连续的Volume，否则tilesplice节点会像下图这样帮你补齐。所以方法三也有不少的限制。 如果时间允许，还是自己开发一套Heightfield的节点来定制需要的功能，原生的HeightField系列节点在内存上也有些浪费，限制也比较多，而方法二和三可以作为临时应急方法。 处理边缘法线问题再运行一次HDA处理，2x2的4个Component的节点确实都做了处理，但是在Component边缘有很明显的接缝问题，在World Normal视图下更明显。 造成法线接缝是Component之间是共享边缘造成的，单个Landscape Component的LandscapeEdit.SetHeightData即便选择计算法线，也会导致边缘因为采样不到旁边Component的顶点，而导致两个Component的不连续，这里我暂时使用了比较暴力的方法，所有的Landscape Comonent 在SetHeightData都不计算法线，而是在最后重新计算整个Landscape的Normal。 再看下修改后多选Component增加一个HeightField Noise的效果。 Height Data处理后，就是Layer Data的处理了，这里把HeightField Noise 改成 HeightField Mask Noise，对Landscpae的4个Layer的Mask做噪声处理，和之前Height Data导入时一样，也会有Component之间的接缝问题。 这种分割图接缝的问题，以前用WorldMachine做Tile Mask时也经常遇到，也就是Tile边缘之间共享顶点的问题。用WM可以少输出一圈边缘的Map的方法来解决，在UE4里也可以使用类似的方法。 在调用的LandscapeEdit.SetAlphaData参数上，在SetAlphaData，当到了边缘索引就跳过，就可以不传边缘的Mask Data进去了。 if(((LayerIndex + 1 ) % XSize) == 0) continue; 再看一下效果，接缝的问题基本上也已经解决了。 总结至此，Houdini技术体系的几个问题的基础解决方案已经完成，后面的文章会逐渐倾向Houdini的地形实际制作部分。 而这些技术案例，大多要基于这个闭环+可选组件的方式来实现，随着技术介绍流程，我也会在Github上定制一个类似Far Cry5的UE4 Houdini Engine版本，希望大家多提宝贵意见。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 基础管线（三） ：UE4 Landscape Component的方式的地形生成和更新 上篇","slug":"Houdini技术体系 基础管线（三） ：UE4 Landscape Component的方式的地形生成和更新 上篇","date":"2018-06-27T21:16:26.000Z","updated":"2019-05-04T11:16:06.977Z","comments":true,"path":"2018/06/28/Houdini技术体系 基础管线（三） ：UE4 Landscape Component的方式的地形生成和更新 上篇/","link":"","permalink":"/2018/06/28/Houdini技术体系 基础管线（三） ：UE4 Landscape Component的方式的地形生成和更新 上篇/","excerpt":"","text":"查看作者原文Authored by TraceYang背景前一节里，解决了Houdini地形无缝导入到UE4的流程问题。但这种方法也有它的局限性，在实际游戏项目里，LA和LD还是偏向在游戏引擎编辑器里工作，他们的一些设计也会影响到地形的信息，那么就需要Houdini对已经导入UE4中并Bake成Landscape的地形资源做二次修改。通常会选择两种方案： 方案一：把整个地形和建筑都导回到Houdini里，重新过程化和调整生成后，再全部导入回UE4做处理。 方案二：使用HDA节点的Input和Output，通过调用Houdini Engine API，直接在UE4里完成调用Houdini过程化节点对地形做修改。 这里方案一不但要求美术和策划对Houdini有一定了解，而且因为Houdini里和引擎的渲染效果不一致。可能还需要导入到UE4里才能看到最终效果，大地形还要做WorldCompositon和LandscapeStreamingProxy的生成。除了地形以外的的场景和建筑部分，还会和GamePlay以及优化显示逻辑相关，通常会包装成BP或Prefab的形式，这些东西要导入Houdini再导回也不仅仅是资源处理的工作。这么看方法一是非常费时费力的方法。这也导致了国内一部分项目虽然是把Houdini的地形引入到制作管线里，但也仅仅是作为WordMachined的替代品，并不能完全发挥Houdini的全部功能。 所以，我们的目标还是方案二的开发方式，除了第一次在Houdini里做完初始地形导入到UE4里生成WorldCompositon后，就不再需要重新导回到Houdini，而是在UE4里调用预先封装好过程化功能的HDA节点来完成功能。这也是近年来Ubisoft在Tom Clancy’s Ghost Recon: Wildlands和Far Cry 5里使用Houdini的方案。具体案例在GDCVault上有GDC2017和GDC2018的相关视频，这里的目标也是要UE4里用类似他们的方法来实现功能。 图：Far Cry 5的地形编辑工具示例。可以直接在编辑器里调用Houdini功能对地形做修改。 但是使用原生的UE4 Houdini Engine的前提下，无缝大地型的UE4内部修改还是会有以下几个问题： 虽然Houdini Engine支持Landscape的读回到Houdini，但他Output只支持使用回读的Landacape Data信息创建一个新的Landscape： 每次修改，都要重新跑一遍上节提到的生成WorldCompositon和LandscapeStreamingProxy的过程，重新对地形对切割，还是非常耽误时间 虽然提供了基于Landscape Component的Input，但Output时每个Component会Cook成一个landscape，导致生成多个Component。 在原生配置下，即便只处理一部分地形的迭代也必须把整个Landsacape Data通过HDA Input到Houdini来进行处理：假如使用Houdini里读入8x8k的地形，内存占用和过程化处理和交换数据量都会变大，从而导致Cook时间变长，降低迭代的速度。 不能基于Componment的控制生成范围，那就需要给HDA额外加入一个选择区域的Input，导致美术工作上变的更加繁琐。 很难在UE里做资源的版本管理，也不方便多人合作地形 对前面提到的一些概念和方法不了解也没关系，我接下来会用示例还原这些过程，直到最终的目标方案的原型，也就是Far Cry 5的功能效果。 图 Far Cry 5 地形编辑器，可以选择一个Terrain的Section或Sector区域来做过程化生成，极大的减小了处理和引擎与Houdini交换的资源量。 时间和篇幅的缘故，本节会分为上下篇，上半部分主要是在如何修改Houdini Engine源码，可以在UE4里基于Landscape Component进行小规模的迭代迭代的功能，下篇则是实现Houdini Engine管线的基础上，如何制作HDA节点，实现各种不同的编辑效果。 使用Houdini制作闭环本节继续使用上一节的场景资源做作为测试用例，讲解一些HDA Input基础知识，让没有Houdini开发经验的程序人员也能很快接手Houdini Engine的改造。首先创建一个用来开发调试用的HDA节点，它的功能就是可以选中UE4场景里的一个Landscape作为Input，通过Houdini Engine把UE4 Landscape Height Data和Layer Data 转换为Heightfiled Height和Mask Data传入到HDA，在HDA里不做任何处理直接输出原始的Height和Mask,再次经过Houdini Engine生成UE4的Landscape Data。 下图就是一个Houdini闭环处理地形的流程展示，不需要打开Houdini，在UE4里就能完成闭环的操作。 如何创建一个SOP（Surface OPerators or geometry nodes ）类型的Houdini Node Input的流程，Houdini Engine的官方文档里也有讲解 https://www.sidefx.com/docs/unreal/_inputs.html 方法一，Houdini里File-&gt;New Asset，按下图的创建一个新的Operator 方法二 创建一个Gemotry节点，Create Digital Asset，在HDA的Parameter里添加一个Operate Path的参数，把这个参数的与Object_Merge的Object做关联。 不论用这两种哪个方法制作都可以得到这个HDA文件，把它加入到UE资源并拖入到Level的话，按下图那样把Input类型选择为Landscape Input，就可以选择要处理LandscapeStreamingProxy。而勾选上最下面的“Export Selected Landscape Components Only”，就可以把Landscape Component作为Input输入给Houdini。但就像一开始提到的，原生Houdini Engine的这个功能并不能满足我们的需求。 基于component的更新的问题如下图所示，原生UE4的Landscape的是支持多选Component Selection的，Houdini Engine也是支持多个Landscape Component 的Input。 选择4x4个Component作为要处理的Landscape信息，然后用Recommit看下结果. 如下图所示，虽然在效果面上，Houdini Enine把读入的LandScape Data转成HeightField Data 输入给Houdini又没有丝毫误差的的Output后转为LandScape Data，但Houdini Engine把这16个Component创建成了16个Landscape，这明显不是想要的结果。 另外要注意的是，新创建的Landscape的Transform和老的Landscape的Transform也不一样，这是Houdini和UE4的高度信息单位不同导致，这个问题也会在后面修改Houdini Engine时造成一定的困扰。而且原生的Component多选功能在Height和Mask更新上也会有一些问题。另外预先提到的一点，虽然Houdini Engine的Landscape的更新上有以上各种问题，但类似读取Landscape的信息来动态摆放，生成植物生态系统等不会修改LandscapeData的功能并不会受影响，这个具体的HDA开发也会在下篇里涉及到。 图：类似FarCry5根据选择地块的Mask信息生成植被的管线，原生的Houdini Engine也是可以胜任的。只需要一些Houdini HDA的功能开发就可以了。 定制Houdini Engine支持基于Component的生成和更新因为时间和篇幅关系，这里提供一个不需要修改UE4源码，只少量修改Houdini Engine就可以解决问题的方法，先进入到UE4的Houdini Engine Plugin工程代码里。 和Landscape相关的功能，是在HoudiniLandscapeUtils和HoudiniEngineUtils里，建议有时间还是全看一遍，这里用注释简单描述下整个数据流程方便定位问题。 Input部分：调用FHoudiniLandscapeUtils::CreateHeightfieldFromLandscapeComponentArray函数，把选择的Landscape Component的Height Data信息转为Houdini的HeightField Data。 1. Extracting the height data 2. Convert the height uint16 data to float 3. Set the HeightfieldData in Houdini 4. Extract and convert all the layers // 1. Extract the uint8 values from the layer // 2. Convert unreal uint8 to float // 3. Set the heighfield data in Houdini Output部分：当数据在Houdini里处理完成后，调用FHoudiniLandscapeUtils::CreateAllLandscapes基于Houdini的volume数据生成Landscape。 // First, we need to extract proper height data from FoundVolumes // Check that all layers/mask have not changed too // Extract the Float Data from the Heightfield // Convert the height data from Houdini&#39;s heightfield to Unreal&#39;s Landscape // Look for all the layers/masks corresponding to the current heightfield // Extract and convert the Landscape layers // Create the actual Landscape 定位到FHoudiniLandscapeUtils::CreateLandscape函数里，它的核心功能把转换后的的uint16的Landsacpe的Height信息（TArray&lt; uint16 &gt;&amp; IntHeightData）和Layer信息（TArray&lt; FLandscapeImportLayerInfo &gt;&amp; ImportLayerInfos），通过调用UE4的ALandscapeProxy::Import来生成一个全新的Landscape。 这里选择的解决方案是不创建新的Landscape，把HeightData和LayerData做适当的封装，直接使用FLandscapeEditDataInterface的SetHeightData和SetAlphaData输入到需要修改的Landscape的对应Component的数据做更新。 Layer Data的处理方法为了讲解简单起见，直接在CreateAllLandscapes函数的后面加上这部分功能。其中的Height Layer的更新相对简单，把之前Import用的TArray&lt; FLandscapeImportLayerInfo &gt; ImportLayerInfos的数据对应的用LandscapeEdit.SetAlphaData传给老的Landscape就可以了。 // Set Layer Data for (int32 LayerIndex = 0; LayerIndex &lt; ImportLayerInfos.Num(); LayerIndex++) { LandscapeEdit.SetAlphaData(ImportLayerInfos[LayerIndex].LayerInfo, SelectLandscapeComponent-&gt;GetSectionBase().X, SelectLandscapeComponent-&gt;GetSectionBase().Y, SelectLandscapeComponent-&gt;GetSectionBase().X + SelectLandscapeComponent-&gt;ComponentSizeQuads, SelectLandscapeComponent-&gt;GetSectionBase().Y + SelectLandscapeComponent-&gt;ComponentSizeQuads, (uint8*)ImportLayerInfos[LayerIndex].LayerData.GetData(), 0); } 然后选中一个Component，给HDA配置上Landscape材质，以及一个HeightField Mask Noise节点，给地形的Groud信息图层信息增加一些噪声 。 左边是处理前的效果，右边是增加噪声后的效果。 可以看到，这里已经把Houdini处理过的Height Mask信息写回到了UE4原本的Landscape Layer上，实现了目标的效果。 Height Data的处理办法和处理Layer Data的方法类似，把Houdini Engine Output的（TArray&lt; uint16 &gt;&amp; IntHeightData）用LandscapeEdit.SetHeightData函数传回给Landscape Component。 ULandscapeInfo* LandscapeInfo = SelectLandscapeComponent-&gt;GetLandscapeProxy()-&gt;GetLandscapeInfo(); FLandscapeEditDataInterface LandscapeEdit(LandscapeInfo); int Num = IntHeightData.Num(); for (int i = 0; i &lt; Num; i++) { // Convert Transform IntHeightData[i] = (IntHeightData[i] - ZeroValueInDigit)* SelectLandscapeScale.Z / OldLandscapeScale.Z + 32768.f; } // Set HeightData LandscapeEdit.SetHeightData(SelectLandscapeComponent-&gt;GetSectionBase().X, SelectLandscapeComponent-&gt;GetSectionBase().Y, SelectLandscapeComponent-&gt;GetSectionBase().X + SelectLandscapeComponent-&gt;ComponentSizeQuads , SelectLandscapeComponent-&gt;GetSectionBase().Y + SelectLandscapeComponent-&gt;ComponentSizeQuads , (uint16*)IntHeightData.GetData(), 0, false ); Convert Transform注释部分的处理，是因为经过重新处理后Houdini的Height Field的Data Range和之前的发生了变化，导致ConvertHeightfieldDataToLandscapeData里生成的HeightData和Transform信息和Input时的Transform信息不匹配，ZeroValueInDigit和OldLandscapeScale.Z分别代表了新地形的Transform信息。需要把两个Transform信息的差异对HeigtData做修正，才能把正确的Height Data写回到Landscape。如果你发现写回的地形整体高了一块或低了一块，或者高度比例和原来不一致，那通常就是这个HeightData的还原处理出错了。所以原始的Landscape Transform也要尽量标准，例如本节示例里初始Landscape的Transform就做的尽量正规化 看下修改代码后的效果，选择一个Landscape Component地块，在HDA节点里增加一个Heightfiled Noise的节点，对Landscape Height Data做一些轻微的噪声修改： 左侧是未处理的，右侧是处理完的。可以看到地块有了噪声的高低差的效果 继续做一个Height Field Erode的测试，用TimeShift来控制Height Field Erode的演算帧数。 下图结果是TimeShift = 30 和 TimeShift = 60的效果对比。基本上实现了用Houdini Engine对一个Landsape Component的修改功能。但是问题也很明显。处理的Component和未处理的Component的边缘高度无法很好的衔接。距离推上生产线，还有不少功能需要开发和支持。 图：Height Field Erode效果生成，相比整个Landscape的演算，一个Component只要几秒内就能完成效果计算。 PS: 6月28日补充，在植被系统的预研究，发现了有绘制选取的方式来提交修改区域，比选择Landscape Component更加灵活。就在这里也补充一遍了。 UE4除了Component Select Tool之外，在Terrain Sculpt Tool里提供Region Selection Tool的功能，这个要比Component Select Tool更加灵活和便捷。但和Component Select Tool一样，这个功能对原生的Houdini Engine并不适用… 如上图所示，Region Selection Tool是Terrain Sculpt Tool里的功能，不过可以借用这个功能来作为Input的Mask Paint来使用。接下来看下怎么扩展Houdini Engine把这个Mask作为Input传到Houdini里去。 Region Selection Tool绘制的Mask的方式，当使用者绘制时，会在FLandscapeToolStrokeMask::Apply函数里根据笔触和权重值，把绘制值添加到class ULandscapeInfo的TMap&lt;FIntPoint,float&gt; SelectedRegion 里的，只有绘制过的区域才会保存在SelectedRegion里，其中FIntPoint代表的是在Landscape里的XY位置信息，作为整型保存，而float为绘制Mask的权重。 拿到了SelectedRegion后，就是要在Houdini Engine里把它作为Mask，输入到HDA中进行处理。Houdini Engine是在FHoudiniLandscapeUtils::CreateHeightfieldFromLandscapeComponent函数里对Height Data和Mask Data进行Input打包的，这里选择在这个函数里加入SelectedRegion的Mask的打包工作。 首先，是根据Houdini里一个Landscape Component的大小MaxX x MaxY，创建出对应的SelectedRegion大小的Mask数组。在LandscapeInfo的SelectedRegion里查找每个点的信息，如果有就复制到对应位置，没有则设置为0。这样，提供给Houdini使用的SelectedRegionData就完成了。 TArray&lt;float&gt; SelectedRegionData; for (int32 X = MinX; X &lt;= MaxX; X++) { for (int32 Y = MinY; Y &lt;= MaxY; Y++) { float RegionSelect = LandscapeInfo-&gt;SelectedRegion.FindRef(FIntPoint(X, Y)); SelectedRegionData.Add(RegionSelect); } } 接下里，跟LayerMask同样的方式，通过C++代码创建一个名为SelectedRegion的Mask节点，并跟其他的Volume Merge到一起。 FString LayerName = &quot;SelectedRegion&quot;; HAPI_NodeId LayerVolumeNodeId = -1; if (!CreateVolumeInputNode(LayerVolumeNodeId, LayerName, ParentId)) return false; HAPI_PartId CurrentPartId = 0; if (!SetHeighfieldData(LayerVolumeNodeId, CurrentPartId, SelectedRegionData, SelectedRegionLayerVolumeInfo, LayerName, ComponentIndex)) return false; if (!CommitVolumeInputNode(LayerVolumeNodeId, InputMergeNodeId, MergeInputIndex)) return false; MergeInputIndex++; 另外，ULandscapeInfo提供了把绘制的SelectedRegion转为Selected Component的功能，这样绘制过过程化的影响区域后，就不用再选择一次Landscpe Component了。这个修改也很简单，在FHoudiniEngineUtils::HapiCreateInputNodeForLandscape函数里，当没有selected components时，就把绘制的区域转换成SelectedComponents。 if ( LandscapeInfo ) { // Get the currently selected components SelectedComponents = LandscapeInfo-&gt;GetSelectedComponents(); // 如果没有selected components，则从绘制区域获取selected components if (SelectedComponents.Num() == 0) SelectedComponents = LandscapeInfo-&gt;GetSelectedRegionComponents(); } 把名为“SelectedRegion”的Mask作为Input输入到HDA后，需要在HDA里对应这个Mask Layer来识别。在HDA的Heightfield Noise节点里，把SelectedRegion作为Mask Layer来使用 这样HeightField只有在有Mask的部分会有Noise的效果，这个同样也可以用在植被的Entity Point Cloud的生成上。 下图的效果，就是在绘制的’X’的区域内，对9个Landscape Component产生噪声变化。 总结Houdini Engine基于Landscape Component的过程化生成，确实可以大幅度的提升生成效率和速度，但是Houdini Engine和HDA制作都还需要一系列的定制开发 对多选Landscape Component的支持，并且解决多个Component之间的接缝问题。 Input不能只有Landscape Component来控制范围，还需要为美术提供选区的功能来控制生成范围，避免Component边界问题。 在下篇中，我们会针对这些问题，继续对Houdini Engine进行定制，以及提供针对不同功能的HDA开发的示例。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 基础管线（二） ：Heightfiled与UE4的无缝导入以及对World Composition的支持","slug":"Houdini技术体系 基础管线（二） ：Heightfiled与UE4的无缝导入以及对World Composition的支持 - Copy","date":"2018-05-31T20:16:26.000Z","updated":"2019-05-04T02:50:42.750Z","comments":true,"path":"2018/06/01/Houdini技术体系 基础管线（二） ：Heightfiled与UE4的无缝导入以及对World Composition的支持 - Copy/","link":"","permalink":"/2018/06/01/Houdini技术体系 基础管线（二） ：Heightfiled与UE4的无缝导入以及对World Composition的支持 - Copy/","excerpt":"","text":"查看作者原文Authored by TraceYang前言传统的制作做比较真实大世界3D关卡地形时，通常的采用的方式是把HeightMap和SplatMap（Layer Mask）导入到引擎的地形系统里，生成Terrain LandScape的地形信息和地表材质的图层信息。再由美术在引擎编辑器做进一步的细化工作。而这些Map的生成，是使用WorldMachine（简称WM）软件来制作的。 图：Ghost Recon Wildlands前期使用WolrdMachine制作的地图 图：除了HeightMap之外，SplatMap也是要从World Machine中生成的 从WorldMachine中Bake出Map后，导入到UE4引擎里，这个教程wiki上比较多，就不多做描述了。 图：把Map导入到UE生成的Landscape 但是传统的WM机制通常会有以下几个问题 WM里预览的地形生成效果跟DCC软件或游戏引擎相比并不美观，也不能像其他工具里直接由美术参与修改 WM导入到引擎需要通过导出Heightmap再导入引擎，当地形比较大时，map生成和写入到硬盘的时间会超过10分钟，对美术迭代修改的成本非常大 WM生成后到引擎后，关卡设计还需要在地形上进行二次开发，从而影响到地形和地表的Map，这时如果需要WM生成部分地形时，整个流程会变的非常混乱。 像Ubisoft在近年来的大世界项目，Ghost Recon Wildlands和FarCry5如里引入了Houdini Pipeline技术，GDCVault上都有介绍，具体的Heightfield替换WorldMachine的制作，会在地形篇提到，管线章节里就不多做叙述了。这里假设你已经用Houdini的HeightField制作了地形，接下来看下怎么能够快速的通过Houdini Engine快速的导入到游戏编辑器里。 Houdini HeightFiled 到UE4 Landscape的无缝生成下图是Houdini HieghtFiled到UE4 Landscape的无缝生成的结果示例，不需要导入贴图，只需把HDA文件拖入到编辑器的Viewport，赋予预制作好的Landscape材质，就可以自动把HDA Cook成UE的landscape资源。 这里假定假定读者已经掌握Landscape Material和Landscape Layer的创建方法，就不多做叙述了。 从上面Houdini Engine的机制图可以看到。我们就是通过HDA文件 Houdini HeightFiled的每一个volume的信息转入到UE4里，这里UE4 Houdini Engine Plugin已经实现了功能帮我们做转换。 首先这里要要让HeightField的Size的设置和最终在UE4里Bake的Landscape Sizes一致。下图是UE官方建议的Landscape的配置。 HDA文件导入到场景后，这里可以看到Landscape 的Component的情况。 管线介绍部分不会对Heighfiled的制作做太多介绍，用Houdini生成地形信息，通常是用两种途径： 方法一：使用HeightField File节点加载一张已有的高度图来生成 在HeightField File 节点里可以配置生成到UE4的Landscape的Size 而具体的对应的UE Landscape的Overall Resultion，可以使用Heightfiled Resample节点 而GridSpacing则对应的是他实际在UE4里的Overall Resultion 当Heighfiled的Grid Spacing比较大时，说明同样大小的地形，对应的更少的顶点，换算到UE里，就是比较小的Landscape Overall Resultion。 Overall Resultion越小，UE里Landscape生成后的顶点数也会更少一些。这样适合在移动终端用较少的资源做出相对比较大的场景。 下面我做几组Height Field Size与UE Landscape Componment的对比，他们最终在UE里的Landscape szie都是8129x8129。只是细节有所不同。 业余学习中我们能把Houdini Engine作为一个黑盒，根据需求来做Size和Grid Spacing的组合来达到想要的目标配置，而真正项目工程里，还是建议由引擎程序根据项目来定制Hengine Engine的Cook Landscape的配置。这个我们在后续的定制更新和修改时也会提到。 方法二：使用Heightfiled节点从0开始生成： 创建这个节点时，就可以选择整个地图的尺寸，其中Size就是为导入到UE4后对应的大小，和方法一一样Grid Spacing来决定Overall Resultion。 其他的就跟方法一是一样的了。这样，就可以根据机器性能，在场景用较低的几何体生成出相对较大的场景。 Heightmap的导入解决了，然后就是HeightField Layer Mask与UE4 Landscape Material Layer的对应设置。 上图中HDA里HeightFiled的volume信息，height对应的就是HeightMap信息，这个Houdini Engine已经自动支持了，而其他的Layer Mask与UE的Landscape Material Layer，则可以通过命名来一一对应。 这里我们让HeightField的Layer Name与UE的Landscape Layer Name保持一致。 左侧的Heithfiled Layer名称和右边UE的Landscape移植，就可以通过Houdini Engine，不导出中间的Map资源，这个过程相比WM的10几分钟要快很多，通常HDA的Cook只要10几秒。 具体的制作过程可以看附件的HDA事例，这里只介绍几个Houdini关键节点的使用。 HeightField Copy Layer的功能就是把你在Houdini里生成的Layer Mask重命名为你想在UE引擎里对应的Landscape Layer的名字。 这样，我们可以从HDA文件直接生成出带地形高度和地表图层信息的场景了。 Houdini HeightFiled 对World Composition的支持无缝大世界游戏场景开发中，一个Landscape不管是在多人协作开发，迭代，还是在Streaming的优化以及打包等，诸多方面都会有很多的不便，所以需要我们把一个大世界的Landscape‘Tile化’。比如一个8x8km的Landscpe可能会切成4x4或8x8的Tile。UE也提供了World Composition的功能。 传统WorldMachine里可以通过Tiled build生成出无缝的Tiled Heightmap和Mask，然后import到UE的Landscape里，这样其实也会增加bake时间，另外把UE4 Landscape的Mask导回给Houdini也是很痛苦的事情（很慢，需要非常大的系统内存）。 好在Houdini 16.5版本后，其实对这部分的支持也加强了，Houdini提供了一个heightfield tilesplit节点就可以做Tile化了，这里我切成了4x4个tile。 再次把HDA加入场景Cook。就可以生成4x4=16个tile的Landscape了。 但是这个用heightfield tilesplit的方法有他的缺陷，一个是会在tile上产生边缘产生接缝露空。 而且这种多个Landscape的方式，和UE4的World Composition机制也有冲突。也不能跨Tile来做地形编辑，其实并不是做无缝大世界地图的正确方法。其实World Composition还是一个整体Landscape，通过把LandscapeStreamingProxy分配到每个子关卡的方式，来进行的Tile分割。 这里提供一个不修改Houdini Engine也能快速的使用World Composition的比较笨的人力办法来解决。 首先，我们不使用splite节点，直接导入一整张地图进来，这样肯定是没有接缝的。 然后类似创建出对应个子关卡，这里假定我们生成2x2的。 接下来，我们选择对应的sublevel，用Move to level工具，就可以把对应的Landscape Component移动到指定的Level里，生成一个LandscapeStreamingProxy 最后给每个Level生成对应的LandscapeStreamingProxy。进行保存。 然后删除掉原始的Landscape，删除之前创建的SubLevel， 勾选Enable World Composition。 UE4就会自动的帮你加载之前的sublevel，生成World Composition。 这样就和UE4默认的Import tiled map生成的World Composition是一样的了。 和前面的地形尺寸对应一样，这里正确的方法其实是要修改Houdini Engine里面的Bake机制，参考Import tiled map里代码的方法，自动的创建关卡和分配Landscape Component，实现整个流程的自动化。否则将来的迭代也会成为问题。 后续问题虽然这里看似Houdini HeightFiled to UE4 Landscape的流程已经打通，但是在实际项目开发中还是会有以下几个问题 目前流程中Heightfiled还是整体的修改和导入，无法支持Landscape Component和Section的更小级别的增量更新 还要考虑World Composition的支持，可以自动的从Landscape的某个单元更新到LandscapeStreamingProxy 后续的基于地形的植被自动生成，山体自动建模等等的生成功能，也是要支持Landscape的最小单元。 对应手游的硬件的考虑，还需要要能生成不同细节的资源等。 最重要的，要把这流程做成引擎内的闭环，让开发人员不需要了解Houdini就能UE4里执行和调用功能。 另外Unity虽然没有提及，但相对实现应该跟UE4类似，而且也可以将Heightfile转换为Terrain Mesh来适配移动设备，这里就不多做介绍了。而上面描述的问题，会在今后的分享中有所解答。关于本文的事例资源会在近期提供一个分享专用的git地址。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系 基础管线（一）：Houdini与Houdini Engine的安装","slug":"Houdini技术体系 基础管线（一） ：Houdini与Houdini Engine的安装","date":"2018-05-30T20:20:26.000Z","updated":"2019-05-04T02:50:45.518Z","comments":true,"path":"2018/05/31/Houdini技术体系 基础管线（一） ：Houdini与Houdini Engine的安装/","link":"","permalink":"/2018/05/31/Houdini技术体系 基础管线（一） ：Houdini与Houdini Engine的安装/","excerpt":"","text":"查看作者原文Authored by TraceYangHoudini 下载与安装在官网 下载最新的Production Build 版本，当前是16.5版本，需要注册帐号PS:公司内网下载还是比较快的，如果是国内网络，下载可能会很慢和不稳定。 安装一路的默认选择就可以后面我们需要使用的，让Houdini能够游戏引擎和DCC衔接的Houdini Engine Asset的选择安装，如果自己研究学习，又已经安装好引擎的话，可以勾选上。但正式项目会由程序员自己来维护Houdini Engine Plugin的代码并集成到编辑器。这个后面会讲到。 安装目录建议就默认目录，然后next到底安装完成 Houdini Engine Plugin安装 如上图所示，如果我们需要把Houdini的功能可以直接被引擎调用，还需要安装Houdini Engine Plugin，如果是自己编译ue引擎，那么需要从github上下载对应版本的Houdini Engine Plugin 连接在这里 https://github.com/sideeffects/HoudiniEngineForUnreal 下载后解包，把文件夹改名为HoudiniEngine，然后拷贝到Engine\\Plugins\\Runtime里 运行GenerateProjectFiles.bat，重新编译引擎，如果看到Houdini Engine的部分是亮的，那就是可以使用了， 如果是暗色的，通常会是引擎和Houdini的版本和路径，与HoudiniEngine的默认配置不一致，那就需要自己修改 打开HoudiniEngineRuntime.Build.cs 按自己安装的Houdini版本和位置HoudiniVersion和HPath就可以了","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"TraceYang大佬的Houdini技术体系大纲","slug":"Houdini技术体系大纲","date":"2018-05-30T19:16:26.000Z","updated":"2019-05-04T02:37:17.227Z","comments":true,"path":"2018/05/31/Houdini技术体系大纲/","link":"","permalink":"/2018/05/31/Houdini技术体系大纲/","excerpt":"","text":"查看作者原文近些年来基于物理渲染（pbr）和开发世界的大场景（open world）类型游戏，不再只是aaa游戏的标准，在手机游戏中的运用也越来越多。pbr经过近几年商业引擎和贴图工具的推动，即便是手游的工作流已经相对成熟。而过程化的大世界制作技术，虽然已经在国外的ubi，ea等aaa项目中采用，但在国内的pc和移动项目中还运用甚少，这里就是结合我个人这1年多来的工作实践结合参考资料，对基于houdini的大世界场景制作技术做一个全面的技术推广。","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"Journey中的沙丘渲染（及其shader实现）","slug":"Journey中的沙丘渲染（及其shader实现）","date":"2018-05-30T19:16:26.000Z","updated":"2019-05-06T14:20:39.528Z","comments":true,"path":"2018/05/31/Journey中的沙丘渲染（及其shader实现）/","link":"","permalink":"/2018/05/31/Journey中的沙丘渲染（及其shader实现）/","excerpt":"","text":"查看作者原文Journey里面的沙丘渲染是很久之前一直想做的，但总是没时间。最近因为项目中在做一个沙丘的场景，所以趁这个机会来做一下。 （在这里事先声明，在场景再现中所用到的技术基本上是在尊重Journey原作的精神下进行的个人创作。由于素材，参数以及个人能力等原因，要完全重现Journey里面的场景十分困难，也没有意义。另外在制作时不会考虑开销，一切以效果为重。本作仅希望通过场景复原过程分享与收获一些风格化渲染的经验。） 场景最终效果： 官方参考图，是游戏里的实景： 图片来源：Sand Rendering in Journey 这是GDC的一个讲座，现在已经可以免费观看了。讲座用的PPT下载链接： http://advances.realtimerendering.com/s2012/thatgamecompany/SandRenderingInJourney_thatgamecompany.pptx 啊 还是忍不住多方几张官方的插图，因为实在是太漂亮了： 沙子上有blingbling的闪光 （知乎好像会莫名其妙的降低图片的分辨率，建议下载ppt观看） 好的，鉴赏完毕，接下来是正片。 建模 Modeling讲座里说了是用一个高度贴图height map进行建模。 用于建模的height map基本方法是把图片下载下来之后，在Maya新建一个平面，把面片数调节为50*50： 然后打开Surfaces-&gt;Sculpt Geometry Tool。打开小窗后，选择Attribute Maps-&gt;Import 点击import，然后在路径导航窗口中选中刚才我们使用的height map。导入后每个点的高度变化可能有些小，所以我做了沿Y轴的缩放，完成后效果如下： 讲座中提到了他们使用B-spline让模型更加平滑。这部分内容主要和建模有关系，这里就不作展开了。 我希望进行渲染的为该场景内的一小部分，所以单独为这个镜头建了一个模，长这样： 基本上就是用Maya的Sculpting工具修修改改一点点捏出来的。Journey风格的山丘，特点就是山头很尖，一定要尖，做山头的时候可以改用soft select 来调节vertex。 改完后把模型导入Unity，打上背光： 阳光的颜色为（253，208，179）。背景的日光有些丑，所以替换成Jouney的抱抱山和游戏场景中灰黄色的天空。山是游戏截图（估计真实的游戏也就是一个图片( :3 )），天空是一个外部剔除的球体，大概长这样： 修改过后镜头里的画面： 这里还导入了一个Unity自带的FirstPersonController。这样就可以愉快的在沙丘上跑了。写shader前的准备工作基本完成。接下来本文将会以讲座所讲内容的倒叙的进行实现（谁叫讲座也是倒过来讲的呢）。 基本的明暗 Diffuse新建一个新的Unlit Shader，建好后加上材质给我们的模型贴上。 首先是一些基本的向量转换的工作，这里贴一下顶点函数： struct appdata{ float4 vertex : POSITION; float2 uv : TEXCOORD0; float3 normal : NORMAL; float4 tangent :TANGENT;}; struct v2f{ float2 uv : TEXCOORD0; float3 worldPos : TEXCOORD1; // position of this vertex in world float3 view : TEXCOORD2; // view direction, from this vertex to viewer float3 tangentDir : TEXCOORD3; // tangent direction in world float3 bitangentDir : TEXCOORD4; // bitangent direction in world float3 normal : NORMAL; UNITY_FOG_COORDS(5) float4 vertex : SV_POSITION; };v2f vert (appdata v){ v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = v.uv; // here we don’t want the main texture to affect the uv o.worldPos = mul(unity_ObjectToWorld ,v.vertex).xyz; o.view = normalize(WorldSpaceViewDir(v.vertex)); o.normal = normalize( mul( unity_ObjectToWorld , v.normal).xyz ) ; o.tangentDir = normalize( mul( unity_ObjectToWorld , float4( v.tangent.xyz, 0) ).xyz ); o.bitangentDir = normalize( cross( o.normal , o.tangentDir) * v.tangent.w ); UNITY_TRANSFER_FOG(o,o.vertex); return o; }视线向量view direction和法线向量normal基本上是做渲染必须的。uv的话没有做转换，因为除了MainTexture之外还有贴图需要使用，所以就不作转换了。world position是一个还算比较常用的向量，所以这里就顺手写了。之后需要使用Normal Map，所以这里需要引入tangent和bitangent向量。 基本的明暗关系，作者使用的是OrenNayar模型，具体的代码在PPT里罗列如下： 并且用如下方法增加对比度： 嗯，所以勤勤恳恳的科学家们呀，你们辛辛苦苦总结的公式，可是会被艺术家们一言不合就改掉的哟~ 最后公式修改如下： fixed OrenNayarDiffuse( fixed3 light, fixed3 view, fixed3 norm, fixed roughness ){ half VdotN = dot( view , norm ); // the function is modifed here // the original one is LdotN = saturate( dot ( light , norm )) half LdotN = saturate( 4 * dot( light, norm * float3( 1 , 0.3 , 1 ) )); half cos_theta_i = LdotN; half theta_r = acos( VdotN ); half theta_i = acos( cos_theta_i ); half cos_phi_diff = dot( normalize( view - norm * VdotN ), normalize( light - norm * LdotN ) ); half alpha = max( theta_i, theta_r ) ; half beta = min( theta_i, theta_r ) ; half sigma2 = roughness * roughness; half A = 1.0 - 0.5 * sigma2 / (sigma2 + 0.33); half B = 0.45 * sigma2 / (sigma2 + 0.09); return saturate( cos_theta_i ) * (A + (B * saturate( cos_phi_diff ) * sin(alpha) * tan(beta))); }把这个公式引入，面片着色器修改如下： fixed4 frag( v2f i ): SV_Target{ float4 mainColor = tex2D( _MainTex , _MainTex_ST.xy * i.uv.xy + _MainTex_ST.zw ); float3 lightDirection = normalize( UnityWorldSpaceLightDir( i.worldPos ) ); float4 lightColor = _LightColor0; float3 viewDirection = normalize( i.view ); float3 halfDirection = normalize( viewDirection + lightDirection); float4 ambientCol = unity_AmbientSky; float4 diffuseColor = lightColor * mainColor * OrenNayarDiffuse( lightDirection , viewDirection , normal , _Roughness) ; return diffuseColor }实现效果如下： 嗯，只有单光源看起来效果不是很好呀，所以多光源支持写起来~ 首先在Pass头部，CGPROGRAM之前写上Lighting On。 然后在面片着色器里加上循环代码： for ( int k = 1 ; k &lt; 4 ; ++k ) { // handle up to 4 lights float4 lightColork = unity_LightColor[k]; float3 lightDirectionk = unity_LightPosition[k].xyz - i.worldPos unity_LightPosition[k].w; if ( lightColork.x + lightColork.y + lightColork.z &gt;0 ) { float4 diffuseColk = lightColork mainColor * ( OrenNayarDiffuse( lightDirectionk , viewDirection , normal , _Roughness) ); diffuseCol += diffuseColk; }}接下来是打光环节，本人也不是专业的灯光，并且在制作过程中灯光也会不断的进行调整。所以这部分仅供参考。主光源（Key Light）不变，是一个从远处往回打的灯光（就是背光的角度），然后Fill Light 打在侧面，做到让场景变得柔和。Rim Light 把山的轮廓强调一下。三个灯光的按添加顺序展示效果如下。 然后是不同Roughness的对比图，左边是Roughness 为0，右边是Roughness为1。好像没什么区别喉。其实更主要的区别会在之后添加specualar的时候看到，在这里我们选择Roughness为0.5。 沙丘表面纹理 Height Map原作者的方法是把下述的四个高度贴图（Height Map）整合起来做成沙丘表面的纹理。 x z 方向的贴图用于不同法线朝向的表面，Steep 和 Shallow贴图分别用于不同的坡度的表面。（原话为：For each vertex of the detail heightmap, wechose the X- or the Z-column based on which derivative was greater, and we lerpedbetween the shallow and steep rows based on the total steepness of the terrain.） 嗯，这么来说的确有些难理解，实际上我们做一下实验就知道了。 if ( _IsNormalXZ &gt; 0 ){ if ( abs( temNormal.z / temNormal.x ) &gt; 1 ) return float3( abs( temNormal.z ) , 0 , 0 ); else return float3( 0 , 0 , abs( temNormal.x ) );} 这里根据模型法向的xz分量大小，对模型进行红色和蓝色的着色，可以看到，这样的的分类把模型按方向分成了四份。 然后上实景的参考图： 可以看到沙丘的纹路总是沿着沙丘的斜面出现。再看看高度贴图，都是有方向性的，是不是可以理解为，X Z 方向的高度贴图实际上是对应不同方向的纹路？实验的结果如下： 中间是带有纹理方向选择的，左右是只含单个方向的纹理的，对比来看的确中间的纹理比较有立体感。不过这个纹理的衔接处还是比较突兀，所以我用了一个atan函数平滑了一下，代码如下： float3 GetSurfaceNormal( float2 uv , float3 temNormal ){ // get the power of xz direction float xzRate = atan( abs( temNormal.z / temNormal.x) ) ; float3 steepX = UnpackNormal( tex2D( _NormalMapSteepX , _NormalMapSteepX_ST.xy * uv.xy + _NormalMapSteepX_ST.zw ) ) ; float3 steepZ = UnpackNormal( tex2D( _NormalMapSteepZ , _NormalMapSteepZ_ST.xy * uv.xy + _NormalMapSteepZ_ST.zw ) ) ; return lerp( steepX , steepZ , xzRate ) ; } 和视频中介绍的高度贴图不同，我使用的是法向贴图，嗯，好像法向贴图的代码写起来比较简单。我用的贴图长这样（都是网上可以搜到的图）： 再导入贴图后，要确认贴图的类型（Texture Type）勾选为Normal map。并且使用的时候需要进行一个坐标转换，转换方法如下： fixed4 frag(v2f i ):SV_Target { … // Get the surface normal detected by the normal map float3 normalSurface = normalize(GetSurfaceNormal( i.uv , i.normal ) ); // &#39;TBN&#39; transform the world space into a tangent space // with the inverse matrix, we can transport the normal from tangent space to world float3x3 TBN = float3x3( normalize( i.tangentDir ) , normalize( i.bitangentDir ) , normalize( i.normal )); TBN = transpose( TBN); // equals to i.tangent * ns.x + i.bitangent * ns.y + i.normal * ns.z float3 normal = mul( TBN , normalSurface ); // Merge the surface normal with the model normal normal = normalize( normal * _SurfaceNormalScale + i.normal); ... }这个转换简单来说就是把在表面坐标系（以Tangent, Bitangent 和 Normal为轴）里的法线向量转换为在世界坐标系（以XYZ为轴）里的法线向量。这个法线方向转换很重要，不然光照效果就会乱了套（不要问我是怎么发现的）。同时这里加入了_SurfaceNormalScale参数，来控制山体表面纹路的深浅。完成后山的法线分布应该是这样的： 之后要做斜度的方向上的分解，和xz方向类似，同样使用了atan函数进行平滑，具体的代码如下： float3 GetSurfaceNormal( float2 uv , float3 temNormal ){ // get the power of xz direction // it repersent the how much we should show the x or z texture float xzRate = atan( abs( temNormal.z / temNormal.x) ) ; xzRate = saturate( pow( xzRate , 9 ) ); // get the steepness // the shallow and steep texture will be lerped based on this value float steepness = atan( 1/ temNormal.y ); steepness = saturate( pow( steepness , 2 ) ); float3 shallowX = UnpackNormal( tex2D( _NormalMapShallowX , _NormalMapShallowX_ST.xy * uv.xy + _NormalMapShallowX_ST.zw ) ) ; float3 shallowZ = UnpackNormal( tex2D( _NormalMapShallowZ , _NormalMapShallowZ_ST.xy * uv.xy + _NormalMapShallowZ_ST.zw ) ) ; float3 shallow = shallowX * shallowZ * _ShallowBumpScale; float3 steepX = UnpackNormal( tex2D( _NormalMapSteepX , _NormalMapSteepX_ST.xy * uv.xy + _NormalMapSteepX_ST.zw ) ) ; float3 steepZ = UnpackNormal( tex2D( _NormalMapSteepZ , _NormalMapSteepZ_ST.xy * uv.xy + _NormalMapSteepZ_ST.zw ) ) ; float3 steep = lerp( steepX , steepZ , xzRate ) ; return normalize( lerp( shallow , steep , steepness ) ); }好了，这部分完成以后，场景的渲染效果如下（_SurfaceNormalScale分别为0.1,0.5和2） ： 风格化高光 Ocean Specualar首先真的很感慨前辈们在那个光照理论还不很成熟的年代能够做出这么好的艺术效果。在讲座中作者表示这个像海洋高光一样的效果其实是不真实的，但是他们试验之后觉得这个效果好，所以在游戏里就加上了（渲染这种东西有时候真的是凭感觉的呀）。 所谓海面高光是什么意思呢，大概就是这样子的吧： 嗯，大概就是有中间的一条光束。 所以那要怎么实现呢。。。讲座里没给出具体的算法。。。所以这部分本人基本靠蒙的。 先是实验了一些Smith GGX，Beckman之类的模型，效果都不是很好。后来突然想起，之前在做水特效的时候，有出现过类似的效果，所以就去查看了一下。发现好像就是最基本的Blinn模型。。。对，就是Blinn，效果反而意外的不错： float MySpecularDistribution( float roughness, float3 lightDir , float3 view , float3 normal , float3 normalDetail ){ // using the blinn model // base shine come use the normal of the object // detail shine use the normal from the detail normal image float3 halfDirection = normalize( view + lightDir); float baseShine = pow( max( 0 , dot( halfDirection , normal ) ) , 10 / baseRoughness ); float shine = pow( max( 0 , dot( halfDirection , normalDetail ) ) , 10 / roughness ) ; return baseShine * shine; }这里的高光分为baseShine和shine。baseShine是用来确定高光的边界，使用的法线是之前所说的加上Normal Map之后的Normal。shine是用来做纹理，就是做出那种波光粼粼的效果，这里的normal实际上是使用了一个新的细节纹理法向贴图，并且把贴图缩小来做到细小的纹理效果。不过由于素材的原因，和目标效果始终有一些微小的差距。最终效果如下： 使用的细节纹理： 和之前的diffuse叠加（线性叠加）在一起后，下过如下： 后期处理的时候加一些bloom效果会进一步提高整体的视觉效果，先卖个关子~ 然后我也试着结合BRDF的知识手动添加了一些高光，但是效果也一般，所以这里就不展开说明了，只是上个效果图： 贴图过滤 Anisotropic Filtering（略）这部分的作用是让在远距离的贴图能够更加清晰，一个比较典型的例子是这样的（注意看远处部分的瓷砖）： 这个算法在Unity里已经被整合好了。在Editor-&gt;Quality Settings里面有一个Anisotropic Textures的选项用于开关这个效果，默认打开。这部分也就不详细说明了（感觉当年Journey团队真辛苦，连这个也要自己做）。 亮片效果 Glitter亮片效果是什么呢，就是在沙子上blingbling的那种效果： 单拎出来是这样滴： 按照讲座中作者的话来说，他们理解的亮片就是沙堆中有一部分的沙子正好朝向观察者，那么它们就会朝你发射光线，从而产生blingbling的效果。嗯，理论上是这样没错，但是这叫我怎么写呀。关于Glitter的效果可以参考2017的siggraph里的这篇文章： http://blog.selfshadow.com/publications/s2017-shading-course/dreamworks/s2017_pbs_dreamworks_notes.pdf​blog.selfshadow.com个人总结下来，做Glitter效果可以分为两个步骤，一个是噪点的制作，另一个是高光的制作。 在讲座中，作者讲了他们的高光制作的过程，一个灰常任性的制作过程。因为传统的高光函数为的参数为pow(N·H，n)，这个公式在上面的海洋高光中也用到了。作者觉得Glitter需要的更多关于人眼方位的信息，所以就把这个公式里的H换成了V，即观察者方向向量。 两者的对比大概是这样的： 嗯。。。。。。。开心就好。 不过光有高光函数是不够的，因为闪光点并不是在沙子上均匀的出现的，相反，它们的分布十分随机，这就需要我们设计一个随机分布的函数来获取这些亮点分布的位置。在讲座中没有说明噪点函数的生成具体方法，所以接下来又要进入瞎蒙时间。 首先准备一个噪点图，这次我用的图大概长这样： 然后根据这个噪点图，进行噪点的处理。这个函数是凭经验试验出来的，放在这里仅供参考： float3 GetGlitterNoise( float2 uv ){ return tex2D( _GlitterTex , _GlitterTex_ST.xy uv.xy + _GlitterTex_ST.zw ) ;}float GliterDistribution( float Glitterness , float3 lightDir , float3 normal, float3 view , float2 uv , float3 pos ){ … float p1 = GetGlitterNoise( uv + float2 ( 0 , _Time.y 0.0005 + view.x 0.0050 )).r; float p2 = GetGlitterNoise( uv + float2 ( _Time.y 0.001 , _Time.y 0.001 + view.y 0.003 )).g; float sum = p1 * p2; // making discrete noise float glitter = max( 0 , pow( sum , _Glitterness ) * _GlitterMutiplyer - 0.5 ) * 2; ... }制作噪点的效果： 颗粒感可以做到这样，而且在场景走起来的时候blingbling的感觉还是有的，不过闪光点的密度太大了。之前不是有一个用N·V求出来的分布函数嘛，那我们就把它拿来当做蒙版吧（这一趴系完全的瞎蒙，如果有读者知道具体的算法可以留言处告诉我）。完整的代码是这样的： float GliterDistribution( float3 lightDir , float3 normal, float3 view , float2 uv , float3 pos ){ float specBase = saturate( 1 - dot( normal , view ) * 2 ); float specPow = pow( specBase , 10 / _GlitterRange ); // A very random function to modify the glitter noise float p1 = GetGlitterNoise( uv + float2 ( 0 , _Time.y * 0.001 + view.x * 0.006 )).r; float p2 = GetGlitterNoise( uv + float2 ( _Time.y * 0.0006 , _Time.y * 0.0005 + view.y * 0.004 )).g; float sum = 4 * p1 * p2; float glitter = pow( sum , _Glitterness ); glitter = max( 0 , glitter * _GlitterMutiplyer - 0.5 ) * 2; float sparkle = glitter * specPow; return sparkle; }添加了Glitter效果的沙丘： Mips Map这是一个在Texture上的类似于LOD的系统，在讲座中有提到，这个技术能够让沙子颗粒感更强。这里就略过了。 距离雾 Fog通过调用宏实现，在新建Shader的时候自带的代码，这里沿用下来。 后期调整 Post Effect目前来说渲染的场景长这样： 和Journey游戏里的场景好像还有点距离，不过其实只要加上一些些Camera特效就会好很多了。 首先是Bloom，把高光部分的光照质感做出来。这里使用的是Unity官方出的Post Processing Stack插件(Post Processing Stack - Asset Store)。 然后调一下颜色： 这里是把Post Processing里的ToneMap 调成Natural，并添加了一个LUT： 最后使用的是一个叫Beautify的插件(Beautify - Asset Store)，添加了一下锐化的效果，并且增加了一点对比度： 对比一下官方提供的图片： 还是挺有意思的( ･´ω`･ ) 本工程已经同步到Github上了，链接（记得点喜欢哟）： AtwoodDeng/JourneySand​github.com图标欢迎吐槽~","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[{"name":"web","slug":"web","permalink":"/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]}]}